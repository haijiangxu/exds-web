# 技术方案与编码规范

## 1. 技术方案概述

本项目为“电力交易辅助决策系统”，采用主流的前后端分离架构，旨在实现功能模块的解耦与高效并行开发。

-   **后端 (Backend):**
    -   **框架:** 基于 Python 的 FastAPI 框架，利用其高性能及自动生成API文档的特性。
    -   **数据库:** 使用 MongoDB，一个灵活的 NoSQL 数据库，非常适合存储时序和半结构化数据。
    -   **核心库:** `pymongo` 用于数据库交互，`passlib` 和 `python-jose` 处理用户认证和安全，`slowapi` 实现接口限流。

-   **前端 (Frontend):**
    -   **框架:** 基于 TypeScript 的 React 框架，利用其组件化和类型安全的优势。
    -   **UI 库:** Material-UI (MUI)，用于快速构建美观、统一的界面。
    -   **图表库:** Recharts，一个与 React 无缝集成的声明式图表库。
    -   **核心库:** `axios` 负责与后端API通信，`react-router-dom` 处理页面路由。

## 2. 后端编码规范

### 2.1. 语言与风格

-   **语言:** Python 3.8+。
-   **代码风格:** 遵循 **PEP 8** 规范。推荐使用 `Black` 或 `Ruff` 等工具自动格式化代码以保持一致性。

### 2.2. 命名约定

-   **变量与函数:** 使用蛇形命名法 (snake_case)，例如 `load_value`。
-   **类:** 使用帕斯卡命名法 (PascalCase)，例如 `UserInDB`。
-   **常量:** 使用全大写蛇形命名法 (UPPER_SNAKE_CASE)，例如 `SECRET_KEY`。

### 2.3. API 设计

-   **RESTful 原则:** API 设计应遵循 RESTful 风格。
-   **数据模型:** 使用 Pydantic 模型进行请求体验证、响应体序列化和文档自动生成。
-   **路由组织:** 使用 `APIRouter` 将相关的API端点组织在不同的模块中，如 `webapp/api/v1.py`。

### 2.4. 类型提示

-   所有新编写的函数和方法都必须包含明确的类型提示，以增强代码可读性和健壮性。

### 2.5. 数据库操作

-   所有数据库操作都应通过 `webapp/tools/mongo.py` 中提供的全局 `DATABASE` 实例进行，禁止直接实例化新的数据库客户端。

### 2.6. 错误处理

-   对于客户端请求错误（如无效参数），应使用 FastAPI 的 `HTTPException` 抛出标准的 HTTP 错误响应。

## 3. 前端编码规范

### 3.1. 语言与风格

-   **语言:** TypeScript。
-   **代码风格:** 推荐使用 `Prettier` 自动格式化代码，确保代码风格统一。

### 3.2. 命名约定

-   **组件:** 使用帕斯卡命名法 (PascalCase)，且文件名与组件名保持一致，例如 `PageHeader.tsx`。
-   **变量与函数:** 使用驼峰命名法 (camelCase)，例如 `getUsers`。

### 3.3. 组件开发

-   **函数式组件:** 优先使用函数式组件和 Hooks (`useState`, `useEffect` 等)。
-   **单一职责:** 保持组件的轻量和功能单一，易于复用和维护。
-   **目录结构:**
    -   通用组件存放于 `src/components/`。
    -   页面级组件存放于 `src/pages/`。

### 3.4. 状态管理

-   对于组件内部状态，使用 `useState` 或 `useReducer`。
-   对于跨组件的全局状态，根据复杂度可引入 `Context API` 或更专业的状态管理库（如 Redux Toolkit）。

### 3.5. API 通信

-   所有与后端的通信都应通过 `src/api/client.ts` 中预配置的 `axios` 实例进行，以便统一处理请求头、拦截器等。

### 3.6. 样式方案

-   遵循项目现有模式，优先使用 Material-UI (MUI) 提供的组件和样式系统。
-   对于特定组件的自定义样式，可创建对应的 `.css` 文件。

### 3.7. 移动端兼容性与图表规范

所有前端开发内容必须严格遵守移动端优先和响应式设计原则，确保在手机、平板和桌面端均有良好的用户体验。

-   **响应式布局 (H5 规范):**
    -   **栅格系统:** 必须使用 Material-UI 的栅格系统 (`<Grid container>`) 进行页面布局，确保元素的灵活性和响应性。
    -   **断点工具:** 充分利用 MUI 的 `sx` 属性和断点工具（如 `{ xs, sm, md, lg, xl }`）来控制元素在不同屏幕尺寸下的显示、隐藏或样式变化。
    -   **视口单位:** 尽量使用相对单位（如 `%`, `rem`, `em`, `vw`, `vh`），避免使用固定的像素（`px`）值，特别是在定义容器宽度和字体大小时。

-   **图表通用规范:**
    -   **峰谷时段背景高亮:**
        -   **要求:** 所有展示96点日曲线的图表（如日负荷曲线、月度典型日曲线等），**必须**在图表背景中根据“尖、峰、平、谷”时段划分，使用不同颜色块进行高亮。
        -   **目的:** 帮助用户直观地将曲线波动与电价时段关联起来。
        -   **实现建议:** 将背景渲染逻辑封装为独立的React组件或可复用函数，方便在各图表模块中统一调用。

### 3.8. 可复用的自定义 Hooks (Reusable Custom Hooks)

为了统一通用功能的实现，避免重复编码，项目封装了以下自定义 Hooks。

#### 3.8.1. `useChartFullscreen` - 移动端图表全屏功能

-   **目的:** 为 Recharts 图表在移动端提供“横屏最大化”查看功能，并集成标题和快捷切换按钮。
-   **文件位置:** `frontend/src/hooks/useChartFullscreen.tsx`
-   **核心逻辑:** 内部封装了 Fullscreen API 和 Screen Orientation API 的调用，管理全屏状态，并提供了一系列 UI 组件用于触发和展示全屏效果。
-   **使用方法:**
    1.  在组件中为图表的父容器（通常是一个 `Box` 或 `Paper`）创建一个 `ref`。
    2.  调用 `useChartFullscreen` Hook，并传入 `ref` 和其他所需参数（如 `title`, `onPrevious`, `onNext`）。
    3.  在 JSX 中，根据 Hook 返回的 `isFullscreen` 状态和 UI 组件（`FullscreenEnterButton`, `FullscreenExitButton`, `FullscreenTitle`, `NavigationButtons`）来自由渲染全屏功能。

-   **代码示例:**
    ```jsx
    const chartRef = useRef<HTMLDivElement>(null);

    const { 
        isFullscreen, 
        FullscreenEnterButton, 
        FullscreenExitButton, 
        FullscreenTitle, 
        NavigationButtons 
    } = useChartFullscreen({
        chartRef: chartRef,
        title: '历史趋势图',
        onPrevious: handlePreviousMonth,
        onNext: handleNextMonth,
    });

    return (
        <Paper ref={chartRef}>
            <FullscreenEnterButton />
            <FullscreenExitButton />
            <FullscreenTitle />
            <NavigationButtons />
            <ResponsiveContainer> ... </ResponsiveContainer>
        </Paper>
    );
    ```

#### 3.8.2. `useSelectableSeries` - Recharts 图表曲线选择功能

-   **目的:** 为 Recharts 图表提供“点击图例（Legend）切换曲线显示/隐藏”的通用能力。
-   **文件位置:** `frontend/src/hooks/useSelectableSeries.tsx`
-   **核心逻辑:** Hook 内部管理一个记录了各曲线可见性的状态对象。它返回该状态对象和一个用于更新状态的事件处理器，组件将它们与 Recharts 的 `Legend` 和 `Line`/`Bar` 等组件的 `hide` 属性进行绑定。
-   **使用方法:**
    1.  在图表组件中，定义一个包含所有曲线 `dataKey` 的 `type` 或 `enum`。
    2.  调用 `useSelectableSeries` Hook，并传入一个定义了所有曲线初始可见性状态的对象。
    3.  将 Hook 返回的 `handleLegendClick` 传递给 `<Legend>` 组件的 `onClick` 属性。
    4.  将 Hook 返回的 `seriesVisibility` 状态对象与每个 `<Line>` 或 `<Bar>` 组件的 `hide` 属性进行绑定。

-   **代码示例:**
    ```tsx
    // 1. 定义 key 的类型
    type SeriesKey = 'seriesA' | 'seriesB';

    // 2. 在组件中调用 Hook
    const { seriesVisibility, handleLegendClick } = useSelectableSeries<SeriesKey>({
        seriesA: true, // 初始可见
        seriesB: false, // 初始隐藏
    });

    // 3. 在 JSX 中绑定
    return (
        <ComposedChart data={data}>
            <Legend onClick={handleLegendClick} />
            <Line dataKey="seriesA" hide={!seriesVisibility.seriesA} />
            <Bar dataKey="seriesB" hide={!seriesVisibility.seriesB} />
        </ComposedChart>
    );
    ```
