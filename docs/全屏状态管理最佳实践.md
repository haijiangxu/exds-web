# 全屏状态管理最佳实践

## 问题描述

在使用 `useChartFullscreen` Hook 实现图表全屏功能时，如果在数据加载（loading）状态变化时卸载图表组件，会导致**全屏状态自动退出**。

### 问题根源

全屏 API (`element.requestFullscreen()`) 将全屏状态绑定到特定的 DOM 元素上。当该元素从 DOM 树中卸载时，浏览器会自动退出全屏状态。

## 核心解决方案

**避免在数据加载时卸载包含全屏功能的组件**

### ❌ 错误做法

```tsx
// 错误：loading 时整个组件被卸载
if (loading) {
    return <CircularProgress />;
}

return (
    <Box ref={chartRef}>
        <FullscreenEnterButton />
        <ResponsiveContainer>
            <LineChart data={data} />
        </ResponsiveContainer>
    </Box>
);
```

**问题**：当用户在全屏状态下点击导航按钮切换日期时，`loading` 变为 `true`，组件被卸载并替换为 `CircularProgress`，导致全屏状态丢失。

### ✅ 正确做法

```tsx
return (
    <Box>
        {/* 首次加载（无数据时）：显示完整 loading */}
        {loading && !data ? (
            <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
                <CircularProgress />
            </Box>
        ) : error ? (
            <Alert severity="error">{error}</Alert>
        ) : data ? (
            <Box sx={{ position: 'relative' }}>
                {/* 数据刷新时的覆盖层（不卸载组件） */}
                {loading && (
                    <Box
                        sx={{
                            position: 'absolute',
                            top: 0, left: 0, right: 0, bottom: 0,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            backgroundColor: 'rgba(255, 255, 255, 0.7)',
                            zIndex: 1000  // 低于全屏按钮的 1400
                        }}
                    >
                        <CircularProgress />
                    </Box>
                )}

                {/* 图表组件 - 在 loading 时不会被卸载 */}
                <Box ref={chartRef}>
                    <FullscreenEnterButton />
                    <FullscreenExitButton />
                    <ResponsiveContainer>
                        <LineChart data={data} />
                    </ResponsiveContainer>
                </Box>
            </Box>
        ) : null}
    </Box>
);
```

**关键点**：
1. **区分首次加载和数据刷新**：
   - 首次加载（`loading && !data`）：显示完整 loading
   - 数据刷新（`loading && data`）：使用半透明覆盖层
2. **保持组件挂载**：图表组件在 loading 时依然挂载在 DOM 中
3. **视觉反馈**：通过覆盖层告知用户数据正在加载

## 配套措施

### 1. 禁用导航控件

防止用户在 loading 时重复触发数据请求：

```tsx
<IconButton onClick={handlePrevious} disabled={loading}>
    <ArrowLeftIcon />
</IconButton>

<DatePicker
    value={selectedDate}
    onChange={setSelectedDate}
    disabled={loading}
/>

<IconButton onClick={handleNext} disabled={loading}>
    <ArrowRightIcon />
</IconButton>
```

### 2. 错误状态处理

```tsx
const [error, setError] = useState<string | null>(null);

const fetchData = async (date: Date) => {
    setLoading(true);
    setError(null);  // 清除旧错误
    try {
        const response = await apiClient.get(`/api/v1/endpoint?date=${format(date, 'yyyy-MM-dd')}`);
        setData(response.data);
    } catch (err: any) {
        setError(err.response?.data?.detail || err.message || '加载数据失败');
        setData([]);
    } finally {
        setLoading(false);
    }
};
```

### 3. zIndex 层级管理

确保覆盖层不遮挡全屏按钮：

```tsx
// 覆盖层 zIndex: 1000
{loading && (
    <Box sx={{ zIndex: 1000, ... }}>
        <CircularProgress />
    </Box>
)}

// 全屏按钮（来自 useChartFullscreen）zIndex: 1400
<Box ref={chartRef} sx={{ zIndex: 1400 }}>
    <FullscreenExitButton />
</Box>
```

## 开发检查清单

在完成带全屏功能的图表组件后，使用以下清单自检：

- [ ] 区分首次加载（`loading && !data`）和数据刷新（`loading && data`）
- [ ] 数据刷新时使用覆盖层而不是卸载组件
- [ ] Loading 时禁用导航按钮和日期选择器（`disabled={loading}`）
- [ ] 覆盖层的 `zIndex` 为 1000（低于全屏按钮的 1400）
- [ ] 添加错误状态处理（`error` state + `Alert` 组件）
- [ ] **测试全屏状态下切换日期不会退出全屏**

## 测试步骤

1. 在移动端设备或浏览器开发者工具的设备模拟器中打开页面
2. 点击图表的全屏按钮，进入横屏全屏模式
3. 在全屏状态下点击左/右导航按钮切换日期
4. **预期结果**：页面应保持全屏状态，数据更新时显示半透明 loading 覆盖层
5. **失败表现**：如果退出全屏，说明组件被卸载了，需要检查 loading 状态的处理逻辑

## 参考实现

已修复的组件示例：
- `frontend/src/components/MarketDashboardTab.tsx`（第 587-677 行）
- `frontend/src/components/DayAheadAnalysisTab.tsx`
- `frontend/src/components/RealTimeAnalysisTab.tsx`
- `frontend/src/components/SpreadAnalysisTab.tsx`

## 相关规范

详细规范请参考 `CLAUDE.md` 第 3.5 节《Loading 状态管理规范》。
