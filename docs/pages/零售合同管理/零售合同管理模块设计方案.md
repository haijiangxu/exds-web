# 零售合同管理模块 - 详细技术设计方案 (完整版)

> **核心设计原则**: 本模块的前后端设计、代码架构、技术细节必须与零售套餐管理、客户档案管理模块保持高度一致。在开发每个会话前，必须分析参考模块的实际代码实现，而非依赖文档描述。

## 一、系统架构设计

### 1.1 功能模块划分

```
零售合同管理模块
├── 合同列表管理
│   ├── 列表展示与筛选
│   ├── 搜索功能
│   └── 快速操作（新增/导入/导出/查看/编辑/删除）
├── 合同配置管理 (单页表单)
│   ├── 基本信息配置（关联套餐、客户、电量、时间）
│   └── 套餐内容展示（只读）
├── 合同详情查看 (只读对话框)
│   ├── 基本信息展示
│   └── 套餐内容展示
├── 合同状态管理 (状态机)
│   ├── 待生效 → 生效（自动判断）
│   └── 生效 → 已过期（自动判断）
└── 合同导入导出功能
    ├── Excel 导入（文件上传、解析、校验、入库）
    └── Excel 导出（数据导出为 .xlsx 格式）
```

### 1.2 技术栈

**前端**：

- React 18 + TypeScript
- Material-UI v7
- React Hook Form（表单管理）
- date-fns（日期处理）

**后端**：

- FastAPI（Python）
- Pydantic（数据模型）
- MongoDB（合同数据存储）
- pandas / openpyxl（Excel 导入导出）

### 1.3 代码一致性要求 ⚠️

**本模块必须在开发时分析以下模块的实际代码，确保技术细节完全一致：**

#### 后端参考模块
- `webapp/api/v1_retail_packages.py` - API 路由设计模式
- `webapp/api/v1_customers.py` - 嵌套数据管理模式（如适用）
- `webapp/models/retail_package.py` - Pydantic 模型定义规范
- `webapp/models/customer.py` - 数据模型规范

**关键要求**：
- 遵循 PEP 8 规范，使用类型提示
- 变量和函数使用 `snake_case`，类名使用 `PascalCase`
- 所有数据库操作通过 `webapp.tools.mongo.DATABASE` 全局实例
- 使用 `HTTPException` 处理客户端错误
- JWT 认证集成：`Depends(get_current_active_user)`
- 使用 `PyObjectId` 处理 MongoDB _id 字段

#### 前端参考模块
- `frontend/src/pages/RetailPackagePage.tsx` - 列表页布局和交互
- `frontend/src/components/PackageEditorDialog.tsx` - 编辑对话框模式
- `frontend/src/components/PackageDetailsDialog.tsx` - 详情对话框模式
- `frontend/src/api/retail-packages.ts` - API 客户端实现

**关键要求**：
- 严格遵循 `CLAUDE.md` 的前端页面设计规范
- Material-UI v7 Grid 组件必须使用 `size` 属性
- 响应式设计：移动端优先，断点 `{ xs, sm, md, lg }`
- 所有 API 请求通过 `frontend/src/api/client.ts` 发出
- 使用 TypeScript，组件命名 PascalCase

## 二、UI 需求方案

### **2.0 UI风格一致性原则 (新增)**

**本模块的前端UI设计将严格遵循零售套餐管理模块已建立的UI风格、布局模式和组件使用规范，以确保用户体验的统一性和视觉的一致性。所有页面和组件都将采用移动端优先的响应式设计，并复用项目已有的可复用Hooks和组件模式。**

### 2.1. 主视图（合同列表页）

页面采用与零售套餐管理模块一致的“上查询、下列表”的双卡片布局，不设页面主标题。

#### 2.1.1. 查询条件卡片

- **描述**：页面顶部的独立 `Paper` 组件，用于封装所有过滤和搜索功能。其样式、内边距和间距将与零售套餐模块的查询卡片保持一致。
- **查询字段**:
    - **套餐名称**: `Select`，内容从零售套餐集合里获取激活状态的记录。
    - **购买用户**: `TextField`，支持模糊搜索。
    - **合同状态**: `Select`，选项：所有、草稿、待生效、生效、已过期。
    - **购电开始月份**: `DatePicker` (月份选择器)。
    - **购电结束月份**: `DatePicker` (月份选择器)。
    - **日期选择器规范**：将严格遵循 `CLAUDE.md/CLAUDE.md/GEMINI.MD` 中“日期选择器规范”的要求，使用 `LocalizationProvider`、`DatePicker`、`ArrowLeftIcon`/`ArrowRightIcon`，并确保响应式宽度 `{ xs: '150px', sm: '200px' }`。
- **操作按钮**:
    - 位于卡片右侧。按钮样式（`variant="contained"`, `color="primary"` 和 `variant="outlined"`）将与零售套餐模块保持一致。
    - **\[ 刷新 \]** 按钮。
    - **\[ 重置 \]** 按钮。

#### 2.1.2. 合同列表卡片

- **描述**：页面下方的独立 `Paper` 组件，用于展示数据列表及其相关操作。其样式、内边距和间距将与零售套餐模块的列表卡片保持一致。
- **内部工具栏**:
    - 位于列表格的上方。工具栏的布局和按钮样式将与零售套餐模块保持一致。
    - **左侧**:
        - **\[ + 新增 \]** 按钮 (`variant="contained"`, `color="primary"`)。
        - **\[ 导入 \]** 按钮 (`variant="outlined"`)。
- **数据表格 (`Table`)**:
    - **表格响应式规范**：将严格遵循 `CLAUDE.md/GEMINI.MD` 中“表格响应式规范”的要求，使用 `TableContainer`、`overflowX: 'auto'`，并确保响应式字体大小和内边距。
    - **列**: 合同编号, 套餐名称, 购买用户, 购买电量, 购电开始月份, 购电结束月份, 合同状态, 操作。
    - **操作列**: 每行包含图标按钮，并根据\*\*状态机（详见第8节）\*\*规则进行禁用/启用。图标样式将与零售套餐模块保持一致。
        - `[ 查看 ]` (VisibilityIcon)
        - `[ 编辑 ]` (EditIcon) - *仅待生效状态可见*
        - `[ 删除 ]` (DeleteIcon) - *仅待生效状态可见*
- **分页组件 (`TablePagination`)**:
    - 位于表格的底部，样式将与零售套餐模块保持一致。

#### 2.1.3. UI/UX 优化

- **操作提示 (Tooltip)**: 表格操作列中的所有图标按钮，在鼠标悬停时都应使用 `Tooltip` 组件显示其功能文字（如“查看”、“编辑”、“删除”），与零售套餐模块保持一致。
- **危险操作二次确认**: 对“删除”等不可逆或关键操作，必须弹出确认对话框，防止用户误操作。确认对话框的样式和交互将与零售套餐模块保持一致。
- **操作反馈**: 所有写操作（保存、删除、导入等）完成后，应使用 `Snackbar` 组件在页面顶部给出明确的成功或失败信息，与零售套餐模块保持一致。

### 2.2. 新建/编辑视图（合同编辑对话框）

**设计要求**：必须分析 `PackageEditorDialog.tsx` 的实际实现，复用其对话框结构、表单布局和交互逻辑。

#### 2.2.1 整体布局

- **桌面端**: `Dialog` 弹窗，`maxWidth="md"`，`disableEnforceFocus` 行为
- **移动端**: 自动切换为 `fullScreen` 全屏模式
- **滚动容器**: `DialogContent` 内部可滚动，支持长表单

#### 2.2.2 卡片一：基本信息

**标题**: "合同基本信息"

**表单字段**（左右两列布局）：

```tsx
<Grid container spacing={{ xs: 1, sm: 2 }}>
  <Grid size={{ xs: 12, md: 6 }}>
    <Autocomplete
      label="套餐名称"
      required
      options={activatedPackages}  // 从零售套餐模块获取已生效的套餐列表
      getOptionLabel={(option) => option.package_name}
      onChange={(event, value) => {
        // 选中后自动加载套餐详情到"卡片二"
        handlePackageSelect(value);
      }}
    />
  </Grid>

  <Grid size={{ xs: 12, md: 6 }}>
    <Autocomplete
      label="购买用户"
      required
      options={activeCustomers}  // 从客户档案模块获取正常状态的客户列表
      getOptionLabel={(option) => option.user_name}
      onChange={(event, value) => handleCustomerSelect(value)}
    />
  </Grid>

  <Grid size={{ xs: 12, md: 6 }}>
    <TextField
      label="购买电量 (kWh)"
      type="number"
      required
      fullWidth
      inputProps={{ min: 0, step: 0.01 }}
    />
  </Grid>

  <Grid size={{ xs: 12, md: 6 }}>
    <DatePicker
      label="购电开始月份"
      views={['year', 'month']}
      required
      // 实现参考 MarketPriceAnalysisPage 的月份选择器
    />
  </Grid>

  <Grid size={{ xs: 12, md: 6 }}>
    <DatePicker
      label="购电结束月份"
      views={['year', 'month']}
      required
      // 需要校验：结束月份 >= 开始月份
    />
  </Grid>
</Grid>
```

**关键实现要求**：
- 套餐和客户选择必须使用 `Autocomplete` 组件，支持搜索
- 分析 `RetailPackagePage.tsx` 或 `CustomerManagementPage.tsx` 的下拉选择实现
- 月份选择器必须使用 `DatePicker` 的 `views={['year', 'month']}` 模式
- 表单验证：必填项、购电结束月份 >= 购电开始月份、购买电量 > 0

#### 2.2.3 卡片二：套餐内容展示（只读）

**标题**: "关联套餐内容"

**实现方式**：
- 当用户在卡片一选择套餐后，自动调用零售套餐 API 获取套餐详情
- 使用 `Typography` 和 `Grid` 以"标签-值"对的形式展示套餐信息
- **禁止编辑**：所有内容为只读展示

**展示内容**（参考零售套餐的数据结构）：
```tsx
<Paper variant="outlined" sx={{ p: { xs: 1, sm: 2 }, mt: 2 }}>
  <Typography variant="h6" gutterBottom>关联套餐内容</Typography>

  {selectedPackage ? (
    <Grid container spacing={2}>
      <Grid size={{ xs: 12, sm: 6 }}>
        <Typography variant="body2" color="text.secondary">套餐类型</Typography>
        <Typography variant="body1">
          {selectedPackage.package_type === 'time_based' ? '分时段' : '不分时段'}
        </Typography>
      </Grid>

      <Grid size={{ xs: 12, sm: 6 }}>
        <Typography variant="body2" color="text.secondary">定价模式</Typography>
        <Typography variant="body1">
          {selectedPackage.pricing_mode === 'fixed_linked' ? '固定+联动' : '价差分成'}
        </Typography>
      </Grid>

      <Grid size={{ xs: 12, sm: 6 }}>
        <Typography variant="body2" color="text.secondary">是否绿电</Typography>
        <Typography variant="body1">
          {selectedPackage.additional_terms?.is_green_energy ? '是' : '否'}
        </Typography>
      </Grid>

      {/* 根据实际套餐数据结构展示更多字段 */}
    </Grid>
  ) : (
    <Typography color="text.secondary">请先选择套餐</Typography>
  )}
</Paper>
```

#### 2.2.4 操作栏

**按钮配置**：
- **编辑模式**：`[ 取消 ]` (variant="outlined") + `[ 保存 ]` (variant="contained", color="primary")
- **表单提交**：使用 React Hook Form 进行数据收集和验证
- **保存逻辑**：
  - 前端验证通过后调用后端 API
  - 成功后显示 `Snackbar` 提示并关闭对话框
  - 失败后在对应字段显示错误信息

### 2.3. 详情视图（合同详情对话框）

**设计要求**：必须分析 `PackageDetailsDialog.tsx` 的实际实现，复用其只读展示模式。

**核心区别**：
- 所有表单控件替换为"标签-值"对的纯文本展示
- 使用 `Typography` 组件展示数据，样式与编辑页保持一致
- 保持卡片结构：基本信息卡片 + 套餐内容卡片

**操作栏按钮**：
- `[ 关闭 ]` (variant="outlined")
- `[ 编辑 ]` (variant="contained", color="primary") - **仅待生效状态显示**
- `[ 复制 ]` (variant="outlined") - 可选功能，复制为新合同

### 2.3. 导入对话框

- **布局**：将采用与新建/编辑/查看对话框类似的 `Dialog` 结构，确保视觉一致性。
- **文件上传**：提供文件选择器，支持上传Excel文件。文件上传组件的样式和交互将与项目现有风格保持一致。
- **导入预览**：可选，可在上传后显示部分数据预览，让用户确认。
- **导入按钮**：触发后端导入逻辑。
- **导入结果反馈**：显示导入成功/失败的合同数量，以及失败原因（如数据格式错误、关联数据不存在等）。结果展示将采用清晰的列表或表格形式，并与项目反馈机制（如 `Snackbar`）结合。

## 三、数据库设计

### 3.1 MongoDB 集合：`retail_contracts`

**设计要求**：参考 `retail_packages` 和 `customers` 集合的设计模式，确保字段命名、索引策略和审计字段的一致性。

**索引策略**：
- 为常用查询字段创建索引：`package_name`, `customer_name`, `purchase_start_month`, `purchase_end_month`
- 考虑复合索引以优化筛选查询性能

**集合结构**:

```javascript
{
  _id: ObjectId,                     // 合同编号，MongoDB自动生成

  // --- 合同基本信息 ---
  package_name: String,              // 套餐名称 (关联零售套餐模块，存储套餐名称)
  package_id: ObjectId,              // 套餐ID (关联零售套餐模块，存储 _id 引用)
  customer_name: String,             // 购买用户名称 (关联客户档案模块，存储客户名称)
  customer_id: ObjectId,             // 客户ID (关联客户档案模块，存储 _id 引用)
  purchasing_electricity_quantity: Number, // 购买电量 (单位：kWh)
  purchase_start_month: Date,        // 购电开始月份 (存储为每月1号，如 "2024-01-01T00:00:00Z")
  purchase_end_month: Date,          // 购电结束月份 (存储为每月1号，如 "2024-12-01T00:00:00Z")

  // --- 关联套餐快照 (可选，用于详情展示) ---
  package_snapshot: {                // 套餐内容快照（创建合同时保存）
    package_type: String,            // 套餐类型："time_based" | "non_time_based"
    pricing_mode: String,            // 定价模式："fixed_linked" | "price_spread"
    is_green_energy: Boolean,        // 是否绿电
    pricing_details: Object          // 定价模型详细参数（根据需求决定是否保存）
  },

  // --- 审计字段 (必须遵循项目规范) ---
  created_by: String,                // 创建人
  created_at: Date,                  // 创建时间
  updated_by: String,                // 更新人
  updated_at: Date                   // 更新时间
}
```

**虚拟字段**（后端计算）：
- `status`: 合同状态（待生效、生效、已过期），根据当前日期和 `purchase_start_month`、`purchase_end_month` 实时计算

## 四、API 设计

### 4.1 合同管理 API

#### 1. 获取合同列表

`GET /api/v1/retail-contracts`

- **Query Parameters**: `package_name`, `purchasing_user`, `status`, `start_month`, `end_month`, `page`, `page_size`

#### 2. 获取合同详情

`GET /api/v1/retail-contracts/{contract_id}`

#### 3. 创建合同

`POST /api/v1/retail-contracts`

- **Request Body**: 包含合同所有配置的 JSON 对象。
- **Success Response**: `201 Created`, `{ "id": "...", "status": "..." }`

#### 4. 更新合同

`PUT /api/v1/retail-contracts/{contract_id}`

- **Request Body**: 包含合同所有配置的 JSON 对象。
*   **Logic**: 后端服务层必须校验，只有 `待生效` 状态的合同才能被更新。
- **Error Response**: `400 Bad Request` (如果合同不是草稿)。

#### 5. 删除合同

`DELETE /api/v1/retail-contracts/{contract_id}`

*   **Logic**: 后端服务层必须校验，只有 `待生效` 状态的合同才能被删除。
- **Success Response**: `204 No Content`
- **Error Response**: `400 Bad Request` (如果合同不是草稿)。

### 4.2 导入 API

#### 1. 导入合同数据

`POST /api/v1/retail-contracts/import`

- **Request Body**: `multipart/form-data`，包含上传的Excel文件。
- **Logic**:
    - 接收Excel文件。
    - 解析文件内容，进行数据校验（例如：必填项、数据格式、关联的套餐和客户是否存在）。
    - 将有效数据批量插入到 `retail_contracts` 集合。
    - 记录导入结果，包括成功数量、失败数量及失败详情。
- **Success Response**: `200 OK`, `{ "total_imported": N, "failed_count": M, "errors": [...] }`
- **Error Response**: `400 Bad Request` (文件格式错误等)。

## 五、前端组件设计

### 5.1 组件树结构

```
RetailContractPage
├── QueryCard (Paper)
└── ListCard (Paper)
    ├── Toolbar (Box)
    └── ContractTable (Table)
        └── TableActions (包含所有操作按钮和逻辑)

ContractEditorDialog
// (用于新建/编辑合同)

ContractDetailsDialog
// (用于查看合同详情)

ContractImportDialog
// (用于导入合同)

DeleteConfirmationDialog
// (用于删除的确认弹窗)

FeedbackSnackbar
// (用于操作结果的全局提示)
```

### 5.2 核心组件实现策略

**⚠️ 强制要求**：在实现每个组件前，必须先分析参考组件的实际代码，理解其实现细节，然后复用其模式。

#### `RetailContractPage.tsx`

**参考代码**：
```
必须分析：frontend/src/pages/RetailPackagePage.tsx
重点关注：
- 页面结构和布局（外层容器、面包屑、双卡片布局）
- 查询条件的表单管理和提交逻辑
- 列表数据的获取、筛选、分页逻辑
- 表格的响应式渲染（桌面端表格、移动端卡片）
- 操作按钮的状态控制和事件处理
- 对话框的打开/关闭状态管理
```

**核心职责**：
- 管理合同列表数据的获取、筛选、分页
- 控制各类对话框的显示/隐藏
- 处理删除、导入、导出等操作

**实现细节**：
1. **查询区域**：
   - 使用 `useState` 管理筛选条件
   - 分析 `RetailPackagePage` 的查询提交逻辑
   - 实现"刷新"和"重置"按钮功能

2. **列表渲染**：
   - 分析 `RetailPackagePage` 的 `renderTableActions` 函数
   - 根据合同虚拟状态动态控制按钮的显示和禁用
   - 实现表格的响应式渲染

3. **状态管理**：
   ```tsx
   const [contracts, setContracts] = useState<Contract[]>([]);
   const [selectedContract, setSelectedContract] = useState<Contract | null>(null);
   const [isEditorOpen, setIsEditorOpen] = useState(false);
   const [isDetailsOpen, setIsDetailsOpen] = useState(false);
   const [isImportOpen, setIsImportOpen] = useState(false);
   ```

#### `ContractEditorDialog.tsx`

**参考代码**：
```
必须分析：frontend/src/components/PackageEditorDialog.tsx
重点关注：
- Dialog 的配置（maxWidth, fullScreen, disableEnforceFocus）
- React Hook Form 的集成和使用
- 辅助渲染函数的组织方式（renderBasicInfoSection 等）
- 表单验证和错误处理
- 关联数据的加载和选择（如 Autocomplete 的使用）
- 提交逻辑和成功/失败反馈
```

**实现细节**：

1. **表单管理**：
   ```tsx
   const { control, handleSubmit, watch, setValue, formState: { errors } } = useForm<ContractFormData>({
     defaultValues: {
       package_name: '',
       customer_name: '',
       purchasing_electricity_quantity: 0,
       purchase_start_month: null,
       purchase_end_month: null
     }
   });
   ```

2. **关联数据加载**：
   ```tsx
   // 加载已生效的套餐列表
   useEffect(() => {
     apiClient.get('/api/v1/retail-packages?status=active')
       .then(res => setPackageOptions(res.data.items))
       .catch(err => console.error('加载套餐列表失败', err));
   }, []);

   // 加载正常状态的客户列表
   useEffect(() => {
     apiClient.get('/api/v1/customers?status=active')
       .then(res => setCustomerOptions(res.data.items))
       .catch(err => console.error('加载客户列表失败', err));
   }, []);
   ```

3. **套餐选择后加载详情**：
   ```tsx
   const handlePackageSelect = (packageId: string) => {
     apiClient.get(`/api/v1/retail-packages/${packageId}`)
       .then(res => setSelectedPackageDetails(res.data))
       .catch(err => console.error('加载套餐详情失败', err));
   };
   ```

4. **辅助渲染函数**：
   ```tsx
   const renderBasicInfoSection = () => (
     <Paper variant="outlined" sx={{ p: { xs: 1, sm: 2 }, mt: 2 }}>
       <Typography variant="h6" gutterBottom>合同基本信息</Typography>
       {/* 表单字段 */}
     </Paper>
   );

   const renderPackageContentSection = () => (
     <Paper variant="outlined" sx={{ p: { xs: 1, sm: 2 }, mt: 2 }}>
       <Typography variant="h6" gutterBottom>关联套餐内容</Typography>
       {/* 只读展示套餐详情 */}
     </Paper>
   );
   ```

#### `ContractDetailsDialog.tsx`

**参考代码**：
```
必须分析：frontend/src/components/PackageDetailsDialog.tsx
重点关注：
- 只读数据的展示方式（Typography + Grid 布局）
- "标签-值"对的样式设计
- 操作栏按钮的配置和事件处理
- 从编辑对话框打开详情对话框的逻辑
```

**实现细节**：
- 复用编辑对话框的卡片结构
- 所有表单控件替换为 `Typography` 展示
- 操作栏包含：关闭、编辑（仅待生效状态）

#### `ContractImportDialog.tsx`

**参考零售套餐模块的导入实现**（如果存在），或参考通用的文件上传模式。

**实现细节**：
1. 文件选择器（input type="file" accept=".xlsx,.xls"）
2. 上传按钮和进度条
3. 导入结果展示（成功数量、失败数量、错误详情）

### 5.3 API 客户端实现

**文件位置**：`frontend/src/api/retail-contracts.ts`

**参考代码**：
```
必须分析：frontend/src/api/retail-packages.ts
重点关注：
- API 方法的命名和参数设计
- 请求和响应的类型定义
- 错误处理模式
```

**示例实现**：
```tsx
import apiClient from './client';

export interface Contract {
  _id: string;
  package_name: string;
  customer_name: string;
  purchasing_electricity_quantity: number;
  purchase_start_month: string;
  purchase_end_month: string;
  status: 'pending' | 'active' | 'expired';
  created_at: string;
  updated_at: string;
}

export const contractApi = {
  getList: (params?: any) => apiClient.get('/api/v1/retail-contracts', { params }),
  getById: (id: string) => apiClient.get(`/api/v1/retail-contracts/${id}`),
  create: (data: any) => apiClient.post('/api/v1/retail-contracts', data),
  update: (id: string, data: any) => apiClient.put(`/api/v1/retail-contracts/${id}`, data),
  delete: (id: string) => apiClient.delete(`/api/v1/retail-contracts/${id}`),
  import: (file: File) => {
    const formData = new FormData();
    formData.append('file', file);
    return apiClient.post('/api/v1/retail-contracts/import', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    });
  },
  export: (params?: any) => apiClient.get('/api/v1/retail-contracts/export', {
    params,
    responseType: 'blob'
  })
};
```

## 六、响应式设计策略

**本模块将完全复用零售套餐管理模块的响应式设计策略，确保在不同尺寸的设备上都提供最佳体验。**

### 6.1 列表页 (`RetailContractPage`)

- **桌面端与平板端 (`md` 及以上断点)**: 采用完整的双卡片布局，查询字段横向排列，列表区域显示为数据表格 (`Table`)。
- **手机端 (`sm` 及以下断点)**:
    - 查询卡片内的字段垂直堆叠。
    - 列表卡片的内容从数据表格切换为**卡片列表视图**，以优化竖屏阅读和触摸体验。

### 6.2 新建/编辑/查看页 (`ContractEditorDialog`, `ContractDetailsDialog`)

- **桌面端与平板端 (`md` 及以上断点)**:
    - 采用**弹窗 (Dialog) 模式**。
    - 表单内部的字段可以根据屏幕宽度采用**两列布局**（例如，`Grid size={{ xs: 12, md: 6 }}`），以提高信息密度，减少滚动。
- **手机端 (`sm` 及以下断点)**:
    - 采用**全屏 (fullScreen) 模式**。
    - 表单内部所有字段强制为单列垂直布局，以保证可读性。

## 七、开发注意事项

-   **数据一致性**：后端必须对所有写操作（`create`, `update`, `delete`, `import`）进行严格的状态和权限校验，不能信任前端传递的数据。
-   **性能优化**：列表页使用分页加载；`useForm` Hook 能有效减少表单重渲染次数。
-   **用户体验**：所有操作（如保存、删除、导入）应有明确的加载（`LoadingButton`）和反馈状态（`Snackbar`）。危险操作（删除）必须有二次确认。
-   **遵循项目规范**：严格遵循 `CLAUDE.md/GEMINI.MD` 中定义的开发规范，特别是 Material-UI v7 `Grid` 组件的 `size` 属性用法。
-   **日期处理**：购电开始/结束月份应统一处理为每月的第一天，以便于比较和存储。

## 八、状态机管理

为保证业务流程的严谨性，合同状态的流转遵循以下状态机模型。此规则在前后端同时强制执行。

### 8.1. 状态定义与流转规则

| 当前状态 | 可执行操作 | 目标状态 | 描述 |
| :--- | :--- | :--- | :--- |
| **(无)** | 新建/导入 | `待生效` | 通过手动创建或导入生成，初始状态为待生效 |
| **待生效** | 编辑、删除 | `待生效` / `(已删除)` | 待生效状态拥有编辑和删除权限 |
| **待生效** | (自动判断) | `生效` | 当当前月份到达“购电开始月份”时自动转换 |
| **生效** | (自动判断) | `已过期` | 当当前月份超过“购电结束月份”时自动转换 |

### 8.2. 实现策略

*   **后端强制**：在 `ContractService` 的 `update_contract`, `delete_contract` 等方法中，第一步就是检查当前记录的**虚拟状态**是否允许执行该操作（即是否为“待生效”），否则直接抛出 `ValueError`，由API层转换为 `400 Bad Request`。
*   **前端引导**：在 `RetailContractPage.tsx` 的 `renderTableActions` 方法中，根据记录的**虚拟状态**动态设置各个 `IconButton` 的 `disabled` 属性或直接不渲染（如编辑、删除按钮），从UI上引导用户执行合法操作。
*   **实时计算状态**：后端服务在返回合同数据时，根据当前日期实时计算生成其**虚拟状态**，无需定时任务。

## 九、导入导出功能设计

### 9.1 导入功能设计（同步方案）

**参考实现**：在会话开发时，检查零售套餐或客户档案模块是否有导入功能的实现，如有则复用其模式。

**导入流程**：

1. **前端上传**：
   - 用户在 `ContractImportDialog` 中选择 Excel 文件
   - 点击"导入"按钮后，文件通过 `multipart/form-data` 上传至 `/api/v1/retail-contracts/import`

2. **后端处理**（同步）：
   ```python
   @router.post("/import", summary="导入合同数据")
   async def import_contracts(
       file: UploadFile = File(...),
       current_user: User = Depends(get_current_active_user)
   ):
       # 1. 读取并解析 Excel 文件（使用 pandas 或 openpyxl）
       # 2. 逐行进行数据校验
       # 3. 校验通过的数据批量插入数据库
       # 4. 返回导入结果
       return {
           "total": 100,
           "success": 95,
           "failed": 5,
           "errors": [
               {"row": 10, "field": "package_name", "message": "套餐不存在"},
               {"row": 23, "field": "customer_name", "message": "客户不存在"}
           ]
       }
   ```

3. **数据校验规则**：
   - **必填项校验**：套餐名称、客户名称、购买电量、购电开始月份、购电结束月份
   - **关联数据校验**：
     - 套餐名称必须存在于 `retail_packages` 集合且状态为 `active`
     - 客户名称必须存在于 `customers` 集合且状态为 `active`
   - **业务逻辑校验**：
     - 购买电量 > 0
     - 购电结束月份 >= 购电开始月份
   - **数据类型校验**：日期格式、数字格式等

4. **前端结果展示**：
   ```tsx
   // 导入完成后显示结果对话框
   <Dialog open={importResultOpen}>
     <DialogTitle>导入结果</DialogTitle>
     <DialogContent>
       <Typography>成功导入：{result.success} 条</Typography>
       <Typography>失败：{result.failed} 条</Typography>

       {result.errors.length > 0 && (
         <Table>
           <TableHead>
             <TableRow>
               <TableCell>行号</TableCell>
               <TableCell>字段</TableCell>
               <TableCell>错误原因</TableCell>
             </TableRow>
           </TableHead>
           <TableBody>
             {result.errors.map((error, index) => (
               <TableRow key={index}>
                 <TableCell>{error.row}</TableCell>
                 <TableCell>{error.field}</TableCell>
                 <TableCell>{error.message}</TableCell>
               </TableRow>
             ))}
           </TableBody>
         </Table>
       )}
     </DialogContent>
   </Dialog>
   ```

### 9.2 导出功能设计

**实现要求**：分析零售套餐或客户档案模块的导出实现（如果存在）。

**后端实现**：
```python
@router.get("/export", summary="导出合同数据")
async def export_contracts(
    package_name: Optional[str] = None,
    customer_name: Optional[str] = None,
    status: Optional[str] = None,
    current_user: User = Depends(get_current_active_user)
):
    # 1. 根据筛选条件查询合同数据
    # 2. 使用 pandas 或 openpyxl 生成 Excel 文件
    # 3. 返回文件流

    return StreamingResponse(
        io.BytesIO(excel_bytes),
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename=contracts_{datetime.now().strftime('%Y%m%d')}.xlsx"}
    )
```

**前端实现**：
```tsx
const handleExport = async () => {
  try {
    const response = await contractApi.export(filterConditions);
    const blob = new Blob([response.data], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `contracts_${new Date().toISOString().slice(0, 10)}.xlsx`;
    link.click();
    window.URL.revokeObjectURL(url);
  } catch (error) {
    console.error('导出失败', error);
    // 显示错误提示
  }
};
```

---