# ä¸šåŠ¡ä»»åŠ¡å®ç°ç¤ºä¾‹

## ğŸ“ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†å…·ä½“çš„ä¸šåŠ¡ä»»åŠ¡å®ç°ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨é€šç”¨å®šæ—¶ä»»åŠ¡æ¡†æ¶æ¥åˆ›å»ºå’Œç®¡ç†å„ç§ä¸šåŠ¡åœºæ™¯çš„å®šæ—¶ä»»åŠ¡ã€‚

## ğŸª å®¢æˆ·ç›¸å…³ä»»åŠ¡

### 1. å®¢æˆ·çŠ¶æ€è‡ªåŠ¨æ›´æ–°ä»»åŠ¡

```python
# webapp/tasks/customer/status_update.py

from typing import Dict, Any
from datetime import datetime, timedelta
from webapp.tasks.base_task import BaseTask, TaskPriority

class CustomerStatusUpdateTask(BaseTask):
    """å®¢æˆ·çŠ¶æ€è‡ªåŠ¨æ›´æ–°ä»»åŠ¡

    åŠŸèƒ½ï¼š
    - æ ¹æ®åˆåŒæ‰§è¡Œæ—¶é—´è‡ªåŠ¨æ›´æ–°å®¢æˆ·çŠ¶æ€
    - å¤„ç†å¾…ç”Ÿæ•ˆ -> æ‰§è¡Œä¸­çš„çŠ¶æ€è½¬æ¢
    - å¤„ç†æ‰§è¡Œä¸­ -> æ„å‘å®¢æˆ·çš„çŠ¶æ€è½¬æ¢ï¼ˆå½“æ‰€æœ‰åˆåŒè¿‡æœŸæ—¶ï¼‰
    """

    @property
    def task_name(self) -> str:
        return "customer_status_auto_update"

    @property
    def task_description(self) -> str:
        return "å®¢æˆ·çŠ¶æ€è‡ªåŠ¨æ›´æ–°ï¼šæ ¹æ®åˆåŒæ‰§è¡Œæ—¶é—´å’Œç³»ç»Ÿæ—¥æœŸè‡ªåŠ¨æ›´æ–°å®¢æˆ·çŠ¶æ€"

    @property
    def task_category(self) -> str:
        return "customer"

    @property
    def task_tags(self) -> list:
        return ["status", "auto", "customer", "contract"]

    @property
    def task_priority(self) -> TaskPriority:
        return TaskPriority.HIGH

    @property
    def default_schedule(self) -> Dict[str, Any]:
        return {
            "trigger": "cron",
            "hour": 2,      # å‡Œæ™¨2ç‚¹æ‰§è¡Œ
            "minute": 0,
            "misfire_grace_time": 300,
            "max_instances": 1
        }

    def validate_execution_environment(self) -> bool:
        """éªŒè¯æ‰§è¡Œç¯å¢ƒ"""
        try:
            # æ£€æŸ¥æ•°æ®åº“è¿æ¥
            from webapp.tools.mongo import DATABASE
            DATABASE.admin.command('ping')

            # æ£€æŸ¥å¿…è¦çš„é›†åˆæ˜¯å¦å­˜åœ¨
            collections = DATABASE.list_collection_names()
            required_collections = ['customers', 'retail_contracts']

            for coll in required_collections:
                if coll not in collections:
                    return False

            return True

        except Exception:
            return False

    async def execute(self, **kwargs) -> Dict[str, Any]:
        """æ‰§è¡Œå®¢æˆ·çŠ¶æ€æ›´æ–°"""
        from webapp.tools.mongo import DATABASE

        start_time = datetime.now()

        try:
            # 1. è·å–æ‰€æœ‰éœ€è¦æ£€æŸ¥çš„å®¢æˆ·
            customers_needing_update = self._get_customers_needing_update()

            update_count = 0
            error_count = 0
            details = []

            # 2. é€ä¸ªå¤„ç†å®¢æˆ·çŠ¶æ€
            for customer in customers_needing_update:
                try:
                    result = self._process_customer_status(customer)
                    if result['updated']:
                        update_count += 1
                        details.append({
                            "customer_id": str(customer['_id']),
                            "customer_name": customer.get('user_name'),
                            "old_status": result['old_status'],
                            "new_status": result['new_status']
                        })

                except Exception as e:
                    error_count += 1
                    details.append({
                        "customer_id": str(customer['_id']),
                        "customer_name": customer.get('user_name'),
                        "error": str(e)
                    })

            # 3. ç”Ÿæˆæ‰§è¡ŒæŠ¥å‘Š
            execution_time = (datetime.now() - start_time).total_seconds()

            return {
                "success": True,
                "message": f"å®¢æˆ·çŠ¶æ€æ›´æ–°å®Œæˆï¼Œå¤„ç† {len(customers_needing_update)} ä¸ªå®¢æˆ·",
                "statistics": {
                    "total_checked": len(customers_needing_update),
                    "status_updates": update_count,
                    "errors": error_count,
                    "execution_time_seconds": execution_time
                },
                "data": {
                    "updated_customers": details[:10],  # åªè¿”å›å‰10ä¸ªè¯¦æƒ…
                    "total_details": len(details)
                }
            }

        except Exception as e:
            return {
                "success": False,
                "message": f"å®¢æˆ·çŠ¶æ€æ›´æ–°å¤±è´¥: {str(e)}",
                "statistics": {
                    "total_checked": 0,
                    "status_updates": 0,
                    "errors": 1,
                    "execution_time_seconds": (datetime.now() - start_time).total_seconds()
                }
            }

    def _get_customers_needing_update(self) -> list:
        """è·å–éœ€è¦çŠ¶æ€æ›´æ–°çš„å®¢æˆ·"""
        from webapp.tools.mongo import DATABASE

        # æŸ¥è¯¢æœ‰åˆåŒä¸”çŠ¶æ€å¯èƒ½éœ€è¦æ›´æ–°çš„å®¢æˆ·
        customers = DATABASE.customers.find({
            "$or": [
                {"status": {"$in": ["prospect", "pending", "active"]}},
                {"status": {"$exists": False}}
            ]
        })

        return list(customers)

    def _process_customer_status(self, customer: dict) -> Dict[str, Any]:
        """å¤„ç†å•ä¸ªå®¢æˆ·çš„çŠ¶æ€æ›´æ–°"""
        from webapp.tools.mongo import DATABASE

        customer_id = str(customer['_id'])
        current_status = customer.get('status', 'prospect')

        # è®¡ç®—åº”æœ‰çš„çŠ¶æ€
        new_status = self._calculate_customer_status(customer_id)

        # å¦‚æœçŠ¶æ€éœ€è¦æ›´æ–°
        if new_status != current_status:
            # æ›´æ–°å®¢æˆ·çŠ¶æ€
            DATABASE.customers.update_one(
                {"_id": customer['_id']},
                {
                    "$set": {
                        "status": new_status,
                        "updated_at": datetime.utcnow(),
                        "updated_by": "auto_status_update"
                    }
                }
            )

            return {
                "updated": True,
                "old_status": current_status,
                "new_status": new_status
            }

        return {
            "updated": False,
            "old_status": current_status,
            "new_status": current_status
        }

    def _calculate_customer_status(self, customer_id: str) -> str:
        """è®¡ç®—å®¢æˆ·åº”æœ‰çš„çŠ¶æ€"""
        from webapp.tools.mongo import DATABASE
        from webapp.models.contract import calculate_contract_status

        # æŸ¥è¯¢å®¢æˆ·çš„åˆåŒ
        contracts = list(DATABASE.retail_contracts.find({
            "customer_id": customer_id
        }))

        if not contracts:
            return "prospect"

        # æ£€æŸ¥åˆåŒçŠ¶æ€
        has_active_contract = False
        has_pending_contract = False

        for contract in contracts:
            purchase_start_month = contract.get('purchase_start_month')
            purchase_end_month = contract.get('purchase_end_month')

            if purchase_start_month and purchase_end_month:
                contract_status = calculate_contract_status(
                    datetime(purchase_start_month.year, purchase_start_month.month, 1),
                    datetime(purchase_end_month.year, purchase_end_month.month, 1)
                )

                if contract_status == "active":
                    has_active_contract = True
                elif contract_status == "pending":
                    has_pending_contract = True

        # ç¡®å®šå®¢æˆ·çŠ¶æ€
        if has_active_contract:
            return "active"
        elif has_pending_contract:
            return "pending"
        else:
            return "prospect"
```

### 2. åˆåŒåˆ°æœŸæé†’ä»»åŠ¡

```python
# webapp/tasks/customer/contract_reminder.py

from typing import Dict, Any, List
from datetime import datetime, timedelta
from webapp.tasks.base_task import BaseTask, TaskPriority

class ContractExpirationReminderTask(BaseTask):
    """åˆåŒåˆ°æœŸæé†’ä»»åŠ¡

    åŠŸèƒ½ï¼š
    - æ£€æŸ¥å³å°†åˆ°æœŸçš„åˆåŒ
    - å‘é€åˆ°æœŸæé†’é€šçŸ¥
    - ç”Ÿæˆç»­çº¦æé†’æŠ¥è¡¨
    """

    @property
    def task_name(self) -> str:
        return "contract_expiration_reminder"

    @property
    def task_description(self) -> str:
        return "åˆåŒåˆ°æœŸæé†’ï¼šæ£€æŸ¥å³å°†åˆ°æœŸçš„åˆåŒå¹¶å‘é€æé†’"

    @property
    def task_category(self) -> str:
        return "customer"

    @property
    def task_tags(self) -> list:
        return ["contract", "reminder", "expiration"]

    @property
    def default_schedule(self) -> Dict[str, Any]:
        return {
            "trigger": "cron",
            "hour": 9,      # ä¸Šåˆ9ç‚¹æ‰§è¡Œ
            "minute": 0,
            "day_of_week": 'mon-fri',  # å·¥ä½œæ—¥æ‰§è¡Œ
            "misfire_grace_time": 300,
            "max_instances": 1
        }

    async def execute(self, **kwargs) -> Dict[str, Any]:
        """æ‰§è¡ŒåˆåŒåˆ°æœŸæé†’"""
        try:
            # 1. è·å–å³å°†åˆ°æœŸçš„åˆåŒ
            expiring_contracts = self._get_expiring_contracts()

            # 2. æŒ‰åˆ°æœŸæ—¶é—´åˆ†ç»„
            contracts_by_period = self._group_by_expiration_period(expiring_contracts)

            # 3. å‘é€æé†’é€šçŸ¥
            reminder_results = await self._send_reminders(contracts_by_period)

            # 4. ç”Ÿæˆæé†’æŠ¥è¡¨
            report_data = self._generate_reminder_report(contracts_by_period)

            return {
                "success": True,
                "message": "åˆåŒåˆ°æœŸæé†’å®Œæˆ",
                "statistics": {
                    "total_contracts_checked": len(expiring_contracts),
                    "contracts_requiring_reminder": sum(len(contracts) for contracts in contracts_by_period.values()),
                    "reminders_sent": reminder_results['sent_count'],
                    "reminders_failed": reminder_results['failed_count']
                },
                "data": {
                    "contracts_by_period": {
                        period: len(contracts)
                        for period, contracts in contracts_by_period.items()
                    },
                    "report": report_data
                }
            }

        except Exception as e:
            return {
                "success": False,
                "message": f"åˆåŒåˆ°æœŸæé†’å¤±è´¥: {str(e)}",
                "statistics": {
                    "total_contracts_checked": 0,
                    "contracts_requiring_reminder": 0,
                    "reminders_sent": 0,
                    "reminders_failed": 1
                }
            }

    def _get_expiring_contracts(self) -> List[Dict[str, Any]]:
        """è·å–å³å°†åˆ°æœŸçš„åˆåŒï¼ˆ90å¤©å†…ï¼‰"""
        from webapp.tools.mongo import DATABASE

        # è®¡ç®—90å¤©åçš„æ—¥æœŸ
        end_date = datetime.now() + timedelta(days=90)

        contracts = DATABASE.retail_contracts.find({
            "purchase_end_month": {
                "$lte": end_date,
                "$gte": datetime.now()
            },
            "status": {"$ne": "expired"}
        }).sort("purchase_end_month", 1)

        return list(contracts)

    def _group_by_expiration_period(self, contracts: List[Dict]) -> Dict[str, List[Dict]]:
        """æŒ‰åˆ°æœŸæ—¶é—´åˆ†ç»„"""
        now = datetime.now()

        contracts_by_period = {
            "7å¤©å†…": [],
            "30å¤©å†…": [],
            "90å¤©å†…": []
        }

        for contract in contracts:
            end_date = contract.get('purchase_end_month')
            if end_date:
                days_until_expiration = (end_date - now).days

                if days_until_expiration <= 7:
                    contracts_by_period["7å¤©å†…"].append(contract)
                elif days_until_expiration <= 30:
                    contracts_by_period["30å¤©å†…"].append(contract)
                else:
                    contracts_by_period["90å¤©å†…"].append(contract)

        return contracts_by_period

    async def _send_reminders(self, contracts_by_period: Dict[str, List[Dict]]) -> Dict[str, int]:
        """å‘é€æé†’é€šçŸ¥"""
        sent_count = 0
        failed_count = 0

        for period, contracts in contracts_by_period.items():
            if not contracts:
                continue

            # æ„å»ºæé†’æ¶ˆæ¯
            message = f"ğŸ“‹ åˆåŒåˆ°æœŸæé†’ï¼ˆ{period}ï¼‰\n\n"
            for contract in contracts:
                customer_name = contract.get('customer_name', 'æœªçŸ¥å®¢æˆ·')
                contract_name = contract.get('contract_name', 'æœªçŸ¥åˆåŒ')
                end_date = contract.get('purchase_end_month')

                if end_date:
                    message += f"â€¢ {customer_name} - {contract_name} (åˆ°æœŸ: {end_date.strftime('%Y-%m-%d')})\n"

            # å‘é€é€šçŸ¥ï¼ˆè¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€é’‰é’‰ã€ä¼å¾®ç­‰ï¼‰
            try:
                await self._send_notification(f"åˆåŒåˆ°æœŸæé†’({period})", message)
                sent_count += 1
            except Exception as e:
                print(f"å‘é€æé†’å¤±è´¥: {str(e)}")
                failed_count += 1

        return {"sent_count": sent_count, "failed_count": failed_count}

    async def _send_notification(self, title: str, message: str):
        """å‘é€é€šçŸ¥ï¼ˆç¤ºä¾‹å®ç°ï¼‰"""
        # è¿™é‡Œå¯ä»¥é›†æˆå„ç§é€šçŸ¥æ¸ é“
        print(f"é€šçŸ¥æ ‡é¢˜: {title}")
        print(f"é€šçŸ¥å†…å®¹: {message}")
        # TODO: é›†æˆé‚®ä»¶ã€é’‰é’‰ç­‰é€šçŸ¥æœåŠ¡

    def _generate_reminder_report(self, contracts_by_period: Dict[str, List[Dict]]) -> Dict[str, Any]:
        """ç”Ÿæˆæé†’æŠ¥è¡¨"""
        report = {
            "ç”Ÿæˆæ—¶é—´": datetime.now().isoformat(),
            "å³å°†åˆ°æœŸåˆåŒç»Ÿè®¡": {},
            "è¯¦ç»†åˆåŒåˆ—è¡¨": []
        }

        for period, contracts in contracts_by_period.items():
            report["å³å°†åˆ°æœŸåˆåŒç»Ÿè®¡"][period] = len(contracts)

            for contract in contracts:
                report["è¯¦ç»†åˆåŒåˆ—è¡¨"].append({
                    "å®¢æˆ·åç§°": contract.get('customer_name'),
                    "åˆåŒåç§°": contract.get('contract_name'),
                    "è´­ç”µå¼€å§‹æ—¶é—´": contract.get('purchase_start_month'),
                    "è´­ç”µç»“æŸæ—¶é—´": contract.get('purchase_end_month'),
                    "è´­ä¹°ç”µé‡": contract.get('purchasing_electricity_quantity'),
                    "å‰©ä½™å¤©æ•°": (contract.get('purchase_end_month', datetime.now()) - datetime.now()).days
                })

        return report
```

## ğŸ“„ åˆåŒç›¸å…³ä»»åŠ¡

### 3. åˆåŒè‡ªåŠ¨è¿‡æœŸå¤„ç†ä»»åŠ¡

```python
# webapp/tasks/contract/expire_processing.py

from typing import Dict, Any
from datetime import datetime, timedelta
from webapp.tasks.base_task import BaseTask, TaskPriority

class ContractExpireProcessingTask(BaseTask):
    """åˆåŒè‡ªåŠ¨è¿‡æœŸå¤„ç†ä»»åŠ¡

    åŠŸèƒ½ï¼š
    - è‡ªåŠ¨æ ‡è®°è¿‡æœŸçš„åˆåŒ
    - å¤„ç†è¿‡æœŸåˆåŒçš„ç›¸å…³ä¸šåŠ¡é€»è¾‘
    - ç”Ÿæˆè¿‡æœŸå¤„ç†æŠ¥å‘Š
    """

    @property
    def task_name(self) -> str:
        return "contract_expire_processing"

    @property
    def task_description(self) -> str:
        return "åˆåŒè‡ªåŠ¨è¿‡æœŸå¤„ç†ï¼šæ ‡è®°è¿‡æœŸåˆåŒå¹¶å¤„ç†ç›¸å…³ä¸šåŠ¡é€»è¾‘"

    @property
    def task_category(self) -> str:
        return "contract"

    @property
    def task_tags(self) -> list:
        return ["contract", "expire", "processing"]

    @property
    def default_schedule(self) -> Dict[str, Any]:
        return {
            "trigger": "cron",
            "hour": 3,      # å‡Œæ™¨3ç‚¹æ‰§è¡Œ
            "minute": 0,
            "misfire_grace_time": 300,
            "max_instances": 1
        }

    async def execute(self, **kwargs) -> Dict[str, Any]:
        """æ‰§è¡ŒåˆåŒè¿‡æœŸå¤„ç†"""
        try:
            # 1. æŸ¥æ‰¾è¿‡æœŸçš„åˆåŒ
            expired_contracts = self._find_expired_contracts()

            # 2. å¤„ç†è¿‡æœŸåˆåŒ
            process_results = await self._process_expired_contracts(expired_contracts)

            # 3. æ›´æ–°ç›¸å…³å®¢æˆ·çŠ¶æ€
            customer_updates = await self._update_related_customers(expired_contracts)

            return {
                "success": True,
                "message": "åˆåŒè¿‡æœŸå¤„ç†å®Œæˆ",
                "statistics": {
                    "expired_contracts_found": len(expired_contracts),
                    "contracts_processed": process_results['processed_count'],
                    "contracts_failed": process_results['failed_count'],
                    "customers_updated": customer_updates['updated_count']
                },
                "data": {
                    "processed_contracts": process_results['details'][:10],
                    "updated_customers": customer_updates['details'][:10]
                }
            }

        except Exception as e:
            return {
                "success": False,
                "message": f"åˆåŒè¿‡æœŸå¤„ç†å¤±è´¥: {str(e)}",
                "statistics": {
                    "expired_contracts_found": 0,
                    "contracts_processed": 0,
                    "contracts_failed": 0,
                    "customers_updated": 0
                }
            }

    def _find_expired_contracts(self) -> list:
        """æŸ¥æ‰¾è¿‡æœŸçš„åˆåŒ"""
        from webapp.tools.mongo import DATABASE

        now = datetime.now()

        contracts = DATABASE.retail_contracts.find({
            "purchase_end_month": {"$lt": now},
            "status": {"$ne": "expired"}
        })

        return list(contracts)

    async def _process_expired_contracts(self, contracts: list) -> Dict[str, Any]:
        """å¤„ç†è¿‡æœŸåˆåŒ"""
        from webapp.tools.mongo import DATABASE

        processed_count = 0
        failed_count = 0
        details = []

        for contract in contracts:
            try:
                # æ ‡è®°åˆåŒä¸ºè¿‡æœŸ
                DATABASE.retail_contracts.update_one(
                    {"_id": contract["_id"]},
                    {
                        "$set": {
                            "status": "expired",
                            "expired_at": datetime.utcnow(),
                            "updated_by": "auto_expire_processing"
                        }
                    }
                )

                processed_count += 1
                details.append({
                    "contract_id": str(contract["_id"]),
                    "contract_name": contract.get("contract_name"),
                    "customer_name": contract.get("customer_name"),
                    "end_date": contract.get("purchase_end_month")
                })

            except Exception as e:
                failed_count += 1
                details.append({
                    "contract_id": str(contract["_id"]),
                    "error": str(e)
                })

        return {
            "processed_count": processed_count,
            "failed_count": failed_count,
            "details": details
        }

    async def _update_related_customers(self, contracts: list) -> Dict[str, Any]:
        """æ›´æ–°ç›¸å…³å®¢æˆ·çŠ¶æ€"""
        from webapp.tools.mongo import DATABASE

        # è·å–å—å½±å“çš„å®¢æˆ·ID
        customer_ids = list(set(contract.get("customer_id") for contract in contracts))
        updated_count = 0
        details = []

        for customer_id in customer_ids:
            try:
                # æ£€æŸ¥å®¢æˆ·æ˜¯å¦è¿˜æœ‰å…¶ä»–ç”Ÿæ•ˆåˆåŒ
                active_contracts = DATABASE.retail_contracts.find({
                    "customer_id": customer_id,
                    "status": "active"
                })

                if not list(active_contracts):
                    # æ²¡æœ‰ç”Ÿæ•ˆåˆåŒï¼Œæ›´æ–°å®¢æˆ·çŠ¶æ€ä¸ºæ„å‘å®¢æˆ·
                    result = DATABASE.customers.update_one(
                        {"_id": ObjectId(customer_id)},
                        {
                            "$set": {
                                "status": "prospect",
                                "updated_at": datetime.utcnow(),
                                "updated_by": "auto_expire_processing"
                            }
                        }
                    )

                    if result.modified_count > 0:
                        updated_count += 1
                        customer = DATABASE.customers.find_one({"_id": ObjectId(customer_id)})
                        details.append({
                            "customer_id": customer_id,
                            "customer_name": customer.get("user_name") if customer else "æœªçŸ¥å®¢æˆ·",
                            "old_status": customer.get("status") if customer else "æœªçŸ¥",
                            "new_status": "prospect"
                        })

            except Exception as e:
                details.append({
                    "customer_id": customer_id,
                    "error": str(e)
                })

        return {
            "updated_count": updated_count,
            "details": details
        }
```

## ğŸ“Š æ•°æ®ç®¡ç†ä»»åŠ¡

### 4. æ•°æ®æ¸…ç†ä»»åŠ¡

```python
# webapp/tasks/data/cleanup.py

from typing import Dict, Any
from datetime import datetime, timedelta
from webapp.tasks.base_task import BaseTask, TaskPriority

class DataCleanupTask(BaseTask):
    """æ•°æ®æ¸…ç†ä»»åŠ¡

    åŠŸèƒ½ï¼š
    - æ¸…ç†è¿‡æœŸçš„æ—¥å¿—æ•°æ®
    - å‹ç¼©å†å²æ•°æ®
    - åˆ é™¤æ— æ•ˆçš„ä¸´æ—¶æ•°æ®
    """

    @property
    def task_name(self) -> str:
        return "data_cleanup"

    @property
    def task_description(self) -> str:
        return "æ•°æ®æ¸…ç†ï¼šæ¸…ç†è¿‡æœŸæ—¥å¿—ã€å‹ç¼©å†å²æ•°æ®ã€åˆ é™¤ä¸´æ—¶æ•°æ®"

    @property
    def task_category(self) -> str:
        return "data"

    @property
    def task_tags(self) -> list:
        return ["cleanup", "maintenance", "data"]

    @property
    def default_schedule(self) -> Dict[str, Any]:
        return {
            "trigger": "cron",
            "hour": 4,      # å‡Œæ™¨4ç‚¹æ‰§è¡Œ
            "minute": 0,
            "day_of_week": 'sun',  # æ¯å‘¨æ—¥å‡Œæ™¨æ‰§è¡Œ
            "misfire_grace_time": 300,
            "max_instances": 1
        }

    async def execute(self, **kwargs) -> Dict[str, Any]:
        """æ‰§è¡Œæ•°æ®æ¸…ç†"""
        try:
            cleanup_results = {
                "log_cleanup": await self._cleanup_logs(),
                "temp_data_cleanup": await self._cleanup_temp_data(),
                "archive_old_data": await self._archive_old_data()
            }

            return {
                "success": True,
                "message": "æ•°æ®æ¸…ç†å®Œæˆ",
                "statistics": {
                    "logs_cleaned": cleanup_results["log_cleanup"]["deleted_count"],
                    "temp_data_cleaned": cleanup_results["temp_data_cleanup"]["deleted_count"],
                    "data_archived": cleanup_results["archive_old_data"]["archived_count"]
                },
                "data": cleanup_results
            }

        except Exception as e:
            return {
                "success": False,
                "message": f"æ•°æ®æ¸…ç†å¤±è´¥: {str(e)}",
                "statistics": {
                    "logs_cleaned": 0,
                    "temp_data_cleaned": 0,
                    "data_archived": 0
                }
            }

    async def _cleanup_logs(self) -> Dict[str, Any]:
        """æ¸…ç†æ—¥å¿—æ•°æ®"""
        from webapp.tools.mongo import DATABASE

        # åˆ é™¤90å¤©å‰çš„æ—¥å¿—
        cutoff_date = datetime.now() - timedelta(days=90)

        # æ¸…ç†æ‰§è¡Œæ—¥å¿—
        result1 = DATABASE.task_execution_logs.delete_many({
            "created_at": {"$lt": cutoff_date}
        })

        # æ¸…ç†é”™è¯¯æ—¥å¿—
        result2 = DATABASE.error_logs.delete_many({
            "created_at": {"$lt": cutoff_date}
        })

        return {
            "deleted_count": result1.deleted_count + result2.deleted_count,
            "execution_logs": result1.deleted_count,
            "error_logs": result2.deleted_count
        }

    async def _cleanup_temp_data(self) -> Dict[str, Any]:
        """æ¸…ç†ä¸´æ—¶æ•°æ®"""
        from webapp.tools.mongo import DATABASE

        # åˆ é™¤è¶…è¿‡24å°æ—¶çš„ä¸´æ—¶æ•°æ®
        cutoff_date = datetime.now() - timedelta(hours=24)

        # æ¸…ç†ä¸´æ—¶ä¸Šä¼ æ–‡ä»¶è®°å½•
        result = DATABASE.temp_files.delete_many({
            "created_at": {"$lt": cutoff_date}
        })

        return {
            "deleted_count": result.deleted_count
        }

    async def _archive_old_data(self) -> Dict[str, Any]:
        """å½’æ¡£æ—§æ•°æ®"""
        # è¿™é‡Œå¯ä»¥å®ç°æ•°æ®å½’æ¡£é€»è¾‘
        # å°†æ—§æ•°æ®ç§»åŠ¨åˆ°å½’æ¡£é›†åˆæˆ–å¯¼å‡ºåˆ°æ–‡ä»¶ç³»ç»Ÿ

        return {
            "archived_count": 0,
            "note": "å½’æ¡£åŠŸèƒ½å¾…å®ç°"
        }
```

## ğŸ“ˆ æŠ¥è¡¨ç”Ÿæˆä»»åŠ¡

### 5. æ—¥æŠ¥ç”Ÿæˆä»»åŠ¡

```python
# webapp/tasks/report/daily_report.py

from typing import Dict, Any
from datetime import datetime, timedelta
from webapp.tasks.base_task import BaseTask, TaskPriority

class DailyReportGenerationTask(BaseTask):
    """æ—¥æŠ¥ç”Ÿæˆä»»åŠ¡

    åŠŸèƒ½ï¼š
    - ç”Ÿæˆæ¯æ—¥ä¸šåŠ¡æŠ¥è¡¨
    - ç»Ÿè®¡å®¢æˆ·ã€åˆåŒã€äº¤æ˜“ç­‰æ•°æ®
    - å‘é€æ—¥æŠ¥é‚®ä»¶
    """

    @property
    def task_name(self) -> str:
        return "daily_report_generation"

    @property
    def task_description(self) -> str:
        return "æ—¥æŠ¥ç”Ÿæˆï¼šç”Ÿæˆæ¯æ—¥ä¸šåŠ¡æŠ¥è¡¨å¹¶å‘é€"

    @property
    def task_category(self) -> str:
        return "report"

    @property
    def task_tags(self) -> list:
        return ["report", "daily", "statistics"]

    @property
    def default_schedule(self) -> Dict[str, Any]:
        return {
            "trigger": "cron",
            "hour": 8,      # ä¸Šåˆ8ç‚¹æ‰§è¡Œ
            "minute": 30,
            "misfire_grace_time": 300,
            "max_instances": 1
        }

    async def execute(self, **kwargs) -> Dict[str, Any]:
        """æ‰§è¡Œæ—¥æŠ¥ç”Ÿæˆ"""
        try:
            # ç”Ÿæˆå‰ä¸€å¤©çš„æ•°æ®æŠ¥è¡¨
            report_date = datetime.now() - timedelta(days=1)

            # 1. æ”¶é›†ä¸šåŠ¡æ•°æ®
            report_data = await self._collect_business_data(report_date)

            # 2. ç”ŸæˆæŠ¥è¡¨
            report_content = self._generate_report_content(report_date, report_data)

            # 3. å‘é€æŠ¥è¡¨
            send_result = await self._send_report(report_date, report_content)

            # 4. ä¿å­˜æŠ¥è¡¨è®°å½•
            await self._save_report_record(report_date, report_data, send_result)

            return {
                "success": True,
                "message": f"æ—¥æŠ¥ç”Ÿæˆå®Œæˆï¼ˆ{report_date.strftime('%Y-%m-%d')}ï¼‰",
                "statistics": {
                    "report_date": report_date.strftime('%Y-%m-%d'),
                    "data_sections": len(report_data),
                    "report_sent": send_result['success'],
                    "report_recipients": len(send_result['recipients']) if send_result['success'] else 0
                },
                "data": report_data
            }

        except Exception as e:
            return {
                "success": False,
                "message": f"æ—¥æŠ¥ç”Ÿæˆå¤±è´¥: {str(e)}",
                "statistics": {
                    "report_date": (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d'),
                    "data_sections": 0,
                    "report_sent": False,
                    "report_recipients": 0
                }
            }

    async def _collect_business_data(self, report_date: datetime) -> Dict[str, Any]:
        """æ”¶é›†ä¸šåŠ¡æ•°æ®"""
        from webapp.tools.mongo import DATABASE

        # è®¡ç®—æ—¥æœŸèŒƒå›´
        start_date = report_date.replace(hour=0, minute=0, second=0, microsecond=0)
        end_date = start_date + timedelta(days=1)

        data = {
            "basic_statistics": await self._get_basic_statistics(start_date, end_date),
            "customer_statistics": await self._get_customer_statistics(start_date, end_date),
            "contract_statistics": await self._get_contract_statistics(start_date, end_date),
            "transaction_statistics": await self._get_transaction_statistics(start_date, end_date)
        }

        return data

    async def _get_basic_statistics(self, start_date: datetime, end_date: datetime) -> Dict[str, Any]:
        """è·å–åŸºç¡€ç»Ÿè®¡æ•°æ®"""
        from webapp.tools.mongo import DATABASE

        # å®¢æˆ·æ€»æ•°
        total_customers = DATABASE.customers.count_documents({})
        active_customers = DATABASE.customers.count_documents({"status": "active"})

        # åˆåŒæ€»æ•°
        total_contracts = DATABASE.retail_contracts.count_documents({})
        active_contracts = DATABASE.retail_contracts.count_documents({"status": "active"})

        return {
            "total_customers": total_customers,
            "active_customers": active_customers,
            "total_contracts": total_contracts,
            "active_contracts": active_contracts
        }

    async def _get_customer_statistics(self, start_date: datetime, end_date: datetime) -> Dict[str, Any]:
        """è·å–å®¢æˆ·ç»Ÿè®¡æ•°æ®"""
        # è·å–æ˜¨æ—¥æ–°å¢å®¢æˆ·æ•°
        new_customers = DATABASE.customers.count_documents({
            "created_at": {"$gte": start_date, "$lt": end_date}
        })

        # è·å–çŠ¶æ€å˜æ›´çš„å®¢æˆ·æ•°
        status_changes = DATABASE.customers.count_documents({
            "updated_at": {"$gte": start_date, "$lt": end_date},
            "updated_by": "auto_status_update"
        })

        return {
            "new_customers": new_customers,
            "status_changes": status_changes
        }

    async def _get_contract_statistics(self, start_date: datetime, end_date: datetime) -> Dict[str, Any]:
        """è·å–åˆåŒç»Ÿè®¡æ•°æ®"""
        # æ–°å¢åˆåŒæ•°
        new_contracts = DATABASE.retail_contracts.count_documents({
            "created_at": {"$gte": start_date, "$lt": end_date}
        })

        # è¿‡æœŸåˆåŒæ•°
        expired_contracts = DATABASE.retail_contracts.count_documents({
            "status": "expired",
            "expired_at": {"$gte": start_date, "$lt": end_date}
        })

        return {
            "new_contracts": new_contracts,
            "expired_contracts": expired_contracts
        }

    async def _get_transaction_statistics(self, start_date: datetime, end_date: datetime) -> Dict[str, Any]:
        """è·å–äº¤æ˜“ç»Ÿè®¡æ•°æ®"""
        # è¿™é‡Œå¯ä»¥æ·»åŠ äº¤æ˜“ç›¸å…³çš„ç»Ÿè®¡
        return {
            "note": "äº¤æ˜“ç»Ÿè®¡æ•°æ®å¾…å®ç°"
        }

    def _generate_report_content(self, report_date: datetime, data: Dict[str, Any]) -> str:
        """ç”ŸæˆæŠ¥è¡¨å†…å®¹"""
        content = f"""
ğŸ“Š ç”µåŠ›äº¤æ˜“è¾…åŠ©å†³ç­–ç³»ç»Ÿ - æ—¥æŠ¥
ğŸ“… æ—¥æœŸï¼š{report_date.strftime('%Yå¹´%mæœˆ%dæ—¥')}
â° ç”Ÿæˆæ—¶é—´ï¼š{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## ğŸ“ˆ åŸºç¡€ç»Ÿè®¡æ•°æ®
â€¢ æ€»å®¢æˆ·æ•°ï¼š{data['basic_statistics']['total_customers']}
â€¢ æ´»è·ƒå®¢æˆ·æ•°ï¼š{data['basic_statistics']['active_customers']}
â€¢ æ€»åˆåŒæ•°ï¼š{data['basic_statistics']['total_contracts']}
â€¢ æ´»è·ƒåˆåŒæ•°ï¼š{data['basic_statistics']['active_contracts']}

## ğŸ‘¥ å®¢æˆ·ç»Ÿè®¡
â€¢ æ–°å¢å®¢æˆ·ï¼š{data['customer_statistics']['new_customers']} ä¸ª
â€¢ çŠ¶æ€å˜æ›´ï¼š{data['customer_statistics']['status_changes']} ä¸ª

## ğŸ“„ åˆåŒç»Ÿè®¡
â€¢ æ–°å¢åˆåŒï¼š{data['contract_statistics']['new_contracts']} ä¸ª
â€¢ è¿‡æœŸåˆåŒï¼š{data['contract_statistics']['expired_contracts']} ä¸ª

## ğŸ’¡ ç³»ç»ŸçŠ¶æ€
âœ… å®šæ—¶ä»»åŠ¡æ­£å¸¸è¿è¡Œ
âœ… æ•°æ®åŒæ­¥æ­£å¸¸å®Œæˆ

---
*æ­¤é‚®ä»¶ç”±ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿å›å¤*
        """

        return content.strip()

    async def _send_report(self, report_date: datetime, content: str) -> Dict[str, Any]:
        """å‘é€æŠ¥è¡¨"""
        try:
            # è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶å‘é€æœåŠ¡
            recipients = ["admin@example.com", "manager@example.com"]

            # TODO: å®ç°é‚®ä»¶å‘é€é€»è¾‘
            print(f"å‘é€æ—¥æŠ¥ç»™: {recipients}")
            print(f"æ—¥æŠ¥å†…å®¹: {content[:200]}...")

            return {
                "success": True,
                "recipients": recipients,
                "sent_time": datetime.now()
            }

        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    async def _save_report_record(self, report_date: datetime, data: Dict[str, Any], send_result: Dict[str, Any]):
        """ä¿å­˜æŠ¥è¡¨è®°å½•"""
        from webapp.tools.mongo import DATABASE

        record = {
            "report_date": report_date,
            "report_type": "daily",
            "data": data,
            "send_result": send_result,
            "created_at": datetime.utcnow()
        }

        DATABASE.daily_reports.insert_one(record)
```

## ğŸ”§ ä»»åŠ¡é…ç½®å’Œç®¡ç†

### ä»»åŠ¡é…ç½®ç¤ºä¾‹

```python
# config/task_configs.py

TASK_CONFIGS = {
    "customer_status_auto_update": {
        "enabled": True,
        "schedule": {
            "trigger": "cron",
            "hour": 2,
            "minute": 0
        },
        "retry_config": {
            "max_retries": 3,
            "retry_delay": 60
        },
        "alert_config": {
            "on_failure": True,
            "on_timeout": True,
            "timeout_minutes": 30
        }
    },

    "contract_expiration_reminder": {
        "enabled": True,
        "schedule": {
            "trigger": "cron",
            "hour": 9,
            "minute": 0,
            "day_of_week": 'mon-fri'
        },
        "alert_config": {
            "on_failure": False,  # éå…³é”®ä»»åŠ¡ï¼Œå¤±è´¥ä¸å‘Šè­¦
            "on_timeout": True,
            "timeout_minutes": 15
        }
    },

    "data_cleanup": {
        "enabled": True,
        "schedule": {
            "trigger": "cron",
            "hour": 4,
            "minute": 0,
            "day_of_week": 'sun'
        }
    },

    "daily_report_generation": {
        "enabled": True,
        "schedule": {
            "trigger": "cron",
            "hour": 8,
            "minute": 30
        }
    }
}
```

## ğŸ“‹ ä½¿ç”¨æŒ‡å—

### 1. åˆ›å»ºæ–°ä»»åŠ¡

1. ç»§æ‰¿ `BaseTask` ç±»
2. å®ç°å¿…éœ€çš„å±æ€§å’Œæ–¹æ³•
3. æ·»åŠ åˆ°ç›¸åº”çš„ä»»åŠ¡æ–‡ä»¶ä¸­
4. ä»»åŠ¡ä¼šè¢«è‡ªåŠ¨æ³¨å†Œ

### 2. é…ç½®ä»»åŠ¡è°ƒåº¦

```python
# åŠ¨æ€æ·»åŠ ä»»åŠ¡
scheduler.add_task("my_new_task", {
    "trigger": "cron",
    "hour": 10,
    "minute": 0
})
```

### 3. ç›‘æ§ä»»åŠ¡æ‰§è¡Œ

```python
# æŸ¥çœ‹ä»»åŠ¡æ‰§è¡Œå†å²
history = task_service.get_task_history("my_task", limit=10)

# æŸ¥çœ‹ä»»åŠ¡çŠ¶æ€
status = scheduler.get_job_info("my_task")
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **ä»»åŠ¡è®¾è®¡åŸåˆ™**ï¼š
   - ä¿æŒä»»åŠ¡ç®€å•å’ŒåŸå­æ€§
   - æ·»åŠ é€‚å½“çš„é”™è¯¯å¤„ç†
   - è®°å½•è¯¦ç»†çš„æ‰§è¡Œæ—¥å¿—
   - è®¾ç½®åˆç†çš„é‡è¯•æœºåˆ¶

2. **æ€§èƒ½è€ƒè™‘**ï¼š
   - ä½¿ç”¨æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
   - æ‰¹é‡å¤„ç†å¤§æ•°æ®é›†
   - é¿å…é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡

3. **ç›‘æ§å’Œå‘Šè­¦**ï¼š
   - è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
   - é…ç½®é€‚å½“çš„å‘Šè­¦é˜ˆå€¼
   - å®šæœŸæ£€æŸ¥ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€

---

*æœ€åæ›´æ–°æ—¶é—´ï¼š2025-11-11*
*ç‰ˆæœ¬ï¼šv1.0*