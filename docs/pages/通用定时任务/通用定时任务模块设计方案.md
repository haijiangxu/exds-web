# é€šç”¨å®šæ—¶ä»»åŠ¡æ¨¡å—è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°äº†ä¸€ä¸ªé€šç”¨çš„å®šæ—¶ä»»åŠ¡æ¨¡å—è®¾è®¡æ–¹æ¡ˆï¼Œæ—¨åœ¨ä¸ºç”µåŠ›äº¤æ˜“è¾…åŠ©å†³ç­–ç³»ç»Ÿæä¾›ä¸€ä¸ªæ ‡å‡†åŒ–çš„ã€å¯æ‰©å±•çš„ã€æ˜“äºç»´æŠ¤çš„å®šæ—¶ä»»åŠ¡ç®¡ç†æ¡†æ¶ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

1. **æ ‡å‡†åŒ–**: æä¾›ç»Ÿä¸€çš„ä»»åŠ¡å®šä¹‰ã€æ³¨å†Œå’Œæ‰§è¡Œæ¥å£
2. **å¯æ‰©å±•**: æ”¯æŒä¸šåŠ¡æ¨¡å—å¿«é€Ÿæ·»åŠ æ–°çš„å®šæ—¶ä»»åŠ¡
3. **å¯é æ€§**: ç¡®ä¿ä»»åŠ¡æ‰§è¡Œçš„ç¨³å®šæ€§å’Œæ•°æ®ä¸€è‡´æ€§
4. **ç›‘æ§æ€§**: æä¾›å®Œæ•´çš„ä»»åŠ¡æ‰§è¡Œç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
5. **å®¹é”™æ€§**: å¤„ç†ä»»åŠ¡æ‰§è¡Œå¤±è´¥ã€ç³»ç»Ÿé‡å¯ç­‰å¼‚å¸¸æƒ…å†µ

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾

```mermaid
graph TB
    A[å®šæ—¶ä»»åŠ¡è°ƒåº¦ä¸­å¿ƒ] --> B[ä»»åŠ¡æ³¨å†Œå™¨]
    A --> C[ä»»åŠ¡æ‰§è¡Œå™¨]
    A --> D[ä»»åŠ¡æŒä¹…åŒ–]
    A --> E[ç›‘æ§å‘Šè­¦]

    B --> F[ä¸šåŠ¡ä»»åŠ¡æ¨¡å—]
    F --> G[å®¢æˆ·çŠ¶æ€æ›´æ–°]
    F --> H[åˆåŒåˆ°æœŸæ£€æŸ¥]
    F --> I[æ•°æ®æ¸…ç†]
    F --> J[æŠ¥è¡¨ç”Ÿæˆ]
    F --> K[å…¶ä»–ä¸šåŠ¡ä»»åŠ¡]

    C --> L[MongoDBä½œä¸šå­˜å‚¨]
    C --> M[çº¿ç¨‹æ± æ‰§è¡Œå™¨]

    D --> N[ä»»åŠ¡é…ç½®å­˜å‚¨]
    D --> O[æ‰§è¡Œå†å²è®°å½•]

    E --> P[æ‰§è¡Œæ—¥å¿—]
    E --> Q[å‘Šè­¦é€šçŸ¥]
```

### ç›®å½•ç»“æ„

```
webapp/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ scheduler_service.py      # æ ¸å¿ƒè°ƒåº¦æœåŠ¡
â”‚   â”œâ”€â”€ task_registry.py          # ä»»åŠ¡æ³¨å†Œå™¨
â”‚   â”œâ”€â”€ task_persistence.py       # ä»»åŠ¡æŒä¹…åŒ–ç®¡ç†
â”‚   â”œâ”€â”€ task_monitor.py          # ä»»åŠ¡ç›‘æ§æœåŠ¡
â”‚   â””â”€â”€ task_executor.py         # ä»»åŠ¡æ‰§è¡Œå™¨
â”œâ”€â”€ tasks/                        # å„ä¸šåŠ¡æ¨¡å—çš„å…·ä½“ä»»åŠ¡
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_task.py            # ä»»åŠ¡åŸºç±»
â”‚   â”œâ”€â”€ customer/               # å®¢æˆ·ç›¸å…³ä»»åŠ¡
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ status_update.py   # å®¢æˆ·çŠ¶æ€æ›´æ–°
â”‚   â”‚   â””â”€â”€ contract_check.py  # åˆåŒçŠ¶æ€æ£€æŸ¥
â”‚   â”œâ”€â”€ contract/               # åˆåŒç›¸å…³ä»»åŠ¡
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ expire_check.py    # åˆåŒåˆ°æœŸæ£€æŸ¥
â”‚   â”‚   â””â”€â”€ auto_renewal.py    # åˆåŒè‡ªåŠ¨ç»­æœŸ
â”‚   â”œâ”€â”€ data/                   # æ•°æ®ç›¸å…³ä»»åŠ¡
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ cleanup.py         # æ•°æ®æ¸…ç†
â”‚   â”‚   â”œâ”€â”€ backup.py          # æ•°æ®å¤‡ä»½
â”‚   â”‚   â””â”€â”€ archive.py         # æ•°æ®å½’æ¡£
â”‚   â””â”€â”€ report/                 # æŠ¥è¡¨ç›¸å…³ä»»åŠ¡
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ daily_report.py    # æ—¥æŠ¥ç”Ÿæˆ
â”‚       â”œâ”€â”€ monthly_report.py  # æœˆæŠ¥ç”Ÿæˆ
â”‚       â””â”€â”€ annual_report.py   # å¹´æŠ¥ç”Ÿæˆ
â”œâ”€â”€ api/
â”‚   â””â”€â”€ v1_scheduler.py         # å®šæ—¶ä»»åŠ¡ç®¡ç†APIæ¥å£
â””â”€â”€ config/
    â””â”€â”€ scheduler_config.py     # è°ƒåº¦å™¨é…ç½®
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. ä»»åŠ¡åŸºç±» (BaseTask)

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from datetime import datetime
from enum import Enum

class TaskStatus(Enum):
    """ä»»åŠ¡çŠ¶æ€æšä¸¾"""
    PENDING = "pending"      # å¾…æ‰§è¡Œ
    RUNNING = "running"      # æ‰§è¡Œä¸­
    SUCCESS = "success"      # æ‰§è¡ŒæˆåŠŸ
    FAILED = "failed"        # æ‰§è¡Œå¤±è´¥
    SKIPPED = "skipped"      # å·²è·³è¿‡

class TaskPriority(Enum):
    """ä»»åŠ¡ä¼˜å…ˆçº§æšä¸¾"""
    LOW = 1
    NORMAL = 2
    HIGH = 3
    CRITICAL = 4

class BaseTask(ABC):
    """å®šæ—¶ä»»åŠ¡åŸºç±»"""

    def __init__(self):
        self.task_id: Optional[str] = None
        self.execution_context: Dict[str, Any] = {}

    @property
    @abstractmethod
    def task_name(self) -> str:
        """ä»»åŠ¡åç§°ï¼Œå¿…é¡»å”¯ä¸€"""
        pass

    @property
    @abstractmethod
    def task_description(self) -> str:
        """ä»»åŠ¡æè¿°"""
        pass

    @property
    @abstractmethod
    def task_category(self) -> str:
        """ä»»åŠ¡åˆ†ç±»"""
        pass

    @property
    def task_tags(self) -> List[str]:
        """ä»»åŠ¡æ ‡ç­¾ï¼Œç”¨äºåˆ†ç±»å’Œæœç´¢"""
        return []

    @property
    def task_priority(self) -> TaskPriority:
        """ä»»åŠ¡ä¼˜å…ˆçº§"""
        return TaskPriority.NORMAL

    @property
    def default_schedule(self) -> Dict[str, Any]:
        """é»˜è®¤è°ƒåº¦é…ç½®"""
        return {
            "trigger": "cron",
            "hour": 2,
            "minute": 0,
            "misfire_grace_time": 300,
            "max_instances": 1
        }

    @property
    def retry_config(self) -> Dict[str, Any]:
        """é‡è¯•é…ç½®"""
        return {
            "max_retries": 3,
            "retry_delay": 60,  # ç§’
            "backoff_factor": 2
        }

    @abstractmethod
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """
        æ‰§è¡Œä»»åŠ¡çš„æ ¸å¿ƒé€»è¾‘

        Returns:
            Dict[str, Any]: æ‰§è¡Œç»“æœ
                - success: bool - æ˜¯å¦æˆåŠŸ
                - message: str - æ‰§è¡Œä¿¡æ¯
                - data: Any - è¿”å›æ•°æ®
                - statistics: Dict - æ‰§è¡Œç»Ÿè®¡ä¿¡æ¯
        """
        pass

    def validate_execution_environment(self) -> bool:
        """éªŒè¯ä»»åŠ¡æ‰§è¡Œç¯å¢ƒ"""
        return True

    def before_execution(self) -> None:
        """æ‰§è¡Œå‰çš„å‡†å¤‡å·¥ä½œ"""
        pass

    def after_execution(self, result: Dict[str, Any]) -> None:
        """æ‰§è¡Œåçš„æ¸…ç†å·¥ä½œ"""
        pass

    def on_failure(self, error: Exception) -> None:
        """æ‰§è¡Œå¤±è´¥æ—¶çš„å¤„ç†"""
        pass
```

### 2. ä»»åŠ¡æ³¨å†Œå™¨ (TaskRegistry)

```python
class TaskRegistry:
    """ä»»åŠ¡æ³¨å†Œå™¨ - å•ä¾‹æ¨¡å¼"""

    def __init__(self):
        self._tasks: Dict[str, BaseTask] = {}
        self._auto_register()

    def register_task(self, task_class: type, task_config: Dict[str, Any] = None) -> None:
        """
        æ³¨å†Œä»»åŠ¡

        Args:
            task_class: ä»»åŠ¡ç±»ï¼Œå¿…é¡»ç»§æ‰¿è‡ªBaseTask
            task_config: ä»»åŠ¡é…ç½®ï¼ˆå¯é€‰ï¼‰
        """
        if not issubclass(task_class, BaseTask):
            raise ValueError(f"ä»»åŠ¡ç±» {task_class.__name__} å¿…é¡»ç»§æ‰¿è‡ª BaseTask")

        task = task_class()
        if task_config:
            task.execution_context.update(task_config)

        self._tasks[task.task_name] = task

    def get_task(self, task_name: str) -> Optional[BaseTask]:
        """è·å–ä»»åŠ¡å®ä¾‹"""
        return self._tasks.get(task_name)

    def list_tasks(self, category: str = None, tags: List[str] = None) -> List[BaseTask]:
        """
        åˆ—å‡ºä»»åŠ¡

        Args:
            category: ä»»åŠ¡åˆ†ç±»è¿‡æ»¤
            tags: ä»»åŠ¡æ ‡ç­¾è¿‡æ»¤

        Returns:
            ç¬¦åˆæ¡ä»¶çš„ä»»åŠ¡åˆ—è¡¨
        """
        tasks = list(self._tasks.values())

        if category:
            tasks = [task for task in tasks if task.task_category == category]

        if tags:
            tasks = [task for task in tasks
                    if any(tag in task.task_tags for tag in tags)]

        return tasks

    def _auto_register(self) -> None:
        """è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰ä»»åŠ¡"""
        # è‡ªåŠ¨å‘ç°å¹¶æ³¨å†Œ tasks ç›®å½•ä¸‹çš„æ‰€æœ‰ä»»åŠ¡
        self._discover_tasks()

    def _discover_tasks(self) -> None:
        """è‡ªåŠ¨å‘ç°ä»»åŠ¡ç±»"""
        # å®ç°è‡ªåŠ¨å‘ç°é€»è¾‘
        pass

# å…¨å±€å•ä¾‹
task_registry = TaskRegistry()
```

### 3. è°ƒåº¦æœåŠ¡ (SchedulerService)

```python
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.jobstores.mongodb import MongoDBJobStore
from apscheduler.executors.pool import ThreadPoolExecutor
from apscheduler.events import EVENT_JOB_EXECUTED, EVENT_JOB_ERROR, EVENT_JOB_MISSED
from datetime import datetime, timedelta

class SchedulerService:
    """é€šç”¨è°ƒåº¦æœåŠ¡"""

    def __init__(self, db):
        self.db = db
        self.scheduler = None
        self.task_persistence = TaskPersistence(db)
        self.task_monitor = TaskMonitor(db)
        self.task_executor = TaskExecutor(db)
        self._init_scheduler()

    def _init_scheduler(self) -> None:
        """åˆå§‹åŒ–è°ƒåº¦å™¨"""
        # MongoDB æŒä¹…åŒ–ä»»åŠ¡çŠ¶æ€
        jobstores = {
            'default': MongoDBJobStore(
                client=db.client,
                database='exds',
                collection='scheduler_jobs'
            )
        }

        # çº¿ç¨‹æ± æ‰§è¡Œå™¨
        executors = {
            'default': ThreadPoolExecutor(max_workers=20)
        }

        # ä½œä¸šé»˜è®¤é…ç½®
        job_defaults = {
            'coalesce': True,           # åˆå¹¶å¤šä¸ªç›¸åŒçš„ä½œä¸š
            'max_instances': 3,         # æœ€å¤§å®ä¾‹æ•°
            'misfire_grace_time': 300   # é”™è¿‡æ‰§è¡Œæ—¶é—´å®½é™
        }

        self.scheduler = BackgroundScheduler(
            jobstores=jobstores,
            executors=executors,
            job_defaults=job_defaults,
            timezone='Asia/Shanghai'
        )

        # æ·»åŠ äº‹ä»¶ç›‘å¬
        self.scheduler.add_listener(
            self._job_executed_listener,
            EVENT_JOB_EXECUTED | EVENT_JOB_ERROR | EVENT_JOB_MISSED
        )

    def start(self) -> None:
        """å¯åŠ¨è°ƒåº¦å™¨"""
        try:
            # æ³¨å†Œæ‰€æœ‰ä»»åŠ¡
            self._register_all_tasks()

            # å¯åŠ¨è°ƒåº¦å™¨
            self.scheduler.start()

            # å¯åŠ¨æ—¶æ£€æŸ¥é”™è¿‡çš„ä»»åŠ¡
            self._check_missed_tasks()

            print("å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨å¯åŠ¨æˆåŠŸ")

        except Exception as e:
            print(f"å¯åŠ¨å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨å¤±è´¥: {str(e)}")
            raise

    def stop(self) -> None:
        """åœæ­¢è°ƒåº¦å™¨"""
        if self.scheduler.running:
            self.scheduler.shutdown()
            print("å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨å·²åœæ­¢")

    def add_task(self, task_name: str, schedule_config: Dict[str, Any]) -> bool:
        """
        åŠ¨æ€æ·»åŠ ä»»åŠ¡

        Args:
            task_name: ä»»åŠ¡åç§°
            schedule_config: è°ƒåº¦é…ç½®

        Returns:
            æ˜¯å¦æ·»åŠ æˆåŠŸ
        """
        try:
            task = task_registry.get_task(task_name)
            if not task:
                raise ValueError(f"ä»»åŠ¡ {task_name} æœªæ‰¾åˆ°")

            self.scheduler.add_job(
                func=self._execute_task_wrapper,
                args=[task],
                id=task_name,
                name=task.task_description,
                replace_existing=True,
                **schedule_config
            )

            # ä¿å­˜è°ƒåº¦é…ç½®
            self.task_persistence.save_task_schedule(task_name, schedule_config)

            return True

        except Exception as e:
            print(f"æ·»åŠ ä»»åŠ¡ {task_name} å¤±è´¥: {str(e)}")
            return False

    def remove_task(self, task_name: str) -> bool:
        """ç§»é™¤ä»»åŠ¡"""
        try:
            if self.scheduler.get_job(task_name):
                self.scheduler.remove_job(task_name)

            self.task_persistence.remove_task_schedule(task_name)
            return True

        except Exception as e:
            print(f"ç§»é™¤ä»»åŠ¡ {task_name} å¤±è´¥: {str(e)}")
            return False

    def pause_task(self, task_name: str) -> bool:
        """æš‚åœä»»åŠ¡"""
        try:
            self.scheduler.pause_job(task_name)
            return True
        except Exception:
            return False

    def resume_task(self, task_name: str) -> bool:
        """æ¢å¤ä»»åŠ¡"""
        try:
            self.scheduler.resume_job(task_name)
            return True
        except Exception:
            return False

    def get_job_info(self, task_name: str = None) -> List[Dict[str, Any]]:
        """è·å–ä»»åŠ¡ä¿¡æ¯"""
        jobs = []
        for job in self.scheduler.get_jobs():
            if task_name and job.id != task_name:
                continue

            job_info = {
                "id": job.id,
                "name": job.name,
                "next_run_time": job.next_run_time.isoformat() if job.next_run_time else None,
                "trigger": str(job.trigger),
                "executor": job.executor,
                "max_instances": job.max_instances
            }
            jobs.append(job_info)

        return jobs

    async def _execute_task_wrapper(self, task: BaseTask) -> Dict[str, Any]:
        """ä»»åŠ¡æ‰§è¡ŒåŒ…è£…å™¨"""
        start_time = datetime.now()
        execution_id = f"{task.task_name}_{int(start_time.timestamp())}"

        try:
            # è®°å½•å¼€å§‹æ‰§è¡Œ
            await self.task_monitor.task_started(
                task.task_name,
                execution_id,
                start_time
            )

            # éªŒè¯æ‰§è¡Œç¯å¢ƒ
            if not task.validate_execution_environment():
                raise Exception("ä»»åŠ¡æ‰§è¡Œç¯å¢ƒéªŒè¯å¤±è´¥")

            # æ‰§è¡Œå‰å‡†å¤‡
            task.before_execution()

            # æ‰§è¡Œä»»åŠ¡
            result = await self.task_executor.execute_task(task, execution_id)

            # æ‰§è¡Œåæ¸…ç†
            task.after_execution(result)

            # è®°å½•æ‰§è¡ŒæˆåŠŸ
            await self.task_monitor.task_completed(
                task.task_name,
                execution_id,
                start_time,
                result
            )

            return result

        except Exception as e:
            # è®°å½•æ‰§è¡Œå¤±è´¥
            error_info = {
                "error_type": type(e).__name__,
                "error_message": str(e),
                "traceback": traceback.format_exc()
            }

            await self.task_monitor.task_failed(
                task.task_name,
                execution_id,
                start_time,
                error_info
            )

            # è°ƒç”¨å¤±è´¥å¤„ç†
            task.on_failure(e)

            # è¿”å›å¤±è´¥ç»“æœ
            return {
                "success": False,
                "message": f"ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {str(e)}",
                "error": error_info,
                "execution_time": (datetime.now() - start_time).total_seconds()
            }

    def _job_executed_listener(self, event) -> None:
        """ä½œä¸šæ‰§è¡Œäº‹ä»¶ç›‘å¬å™¨"""
        if event.exception:
            print(f"ä»»åŠ¡ {event.job_id} æ‰§è¡Œå¤±è´¥: {event.exception}")
            # å‘é€å‘Šè­¦é€šçŸ¥
            self.task_monitor.send_alert(
                f"ä»»åŠ¡æ‰§è¡Œå¤±è´¥",
                f"ä»»åŠ¡ {event.job_id} æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {event.exception}",
                "error"
            )
        else:
            print(f"ä»»åŠ¡ {event.job_id} æ‰§è¡ŒæˆåŠŸ")
```

## ğŸ“Š ä¸šåŠ¡ä»»åŠ¡ç¤ºä¾‹

### å®¢æˆ·çŠ¶æ€æ›´æ–°ä»»åŠ¡

```python
class CustomerStatusUpdateTask(BaseTask):
    """å®¢æˆ·çŠ¶æ€è‡ªåŠ¨æ›´æ–°ä»»åŠ¡"""

    @property
    def task_name(self) -> str:
        return "customer_status_auto_update"

    @property
    def task_description(self) -> str:
        return "å®¢æˆ·çŠ¶æ€è‡ªåŠ¨æ›´æ–°ä»»åŠ¡ï¼šæ ¹æ®åˆåŒæ‰§è¡Œæ—¶é—´å’Œç³»ç»Ÿæ—¥æœŸè‡ªåŠ¨æ›´æ–°å®¢æˆ·çŠ¶æ€"

    @property
    def task_category(self) -> str:
        return "customer"

    @property
    def task_tags(self) -> List[str]:
        return ["status", "auto", "customer"]

    @property
    def default_schedule(self) -> Dict[str, Any]:
        return {
            "trigger": "cron",
            "hour": 2,
            "minute": 0,
            "misfire_grace_time": 300,
            "max_instances": 1
        }

    async def execute(self, **kwargs) -> Dict[str, Any]:
        from webapp.services.customer_service import CustomerService
        from webapp.tools.mongo import DATABASE

        service = CustomerService(DATABASE)

        try:
            # è·å–æ‰€æœ‰éœ€è¦çŠ¶æ€æ£€æŸ¥çš„å®¢æˆ·
            customers = service.get_customers_needing_status_update()

            update_count = 0
            error_count = 0
            errors = []

            for customer in customers:
                try:
                    # è®¡ç®—åº”æœ‰çš„çŠ¶æ€
                    new_status = service.calculate_customer_status(customer)

                    # å¦‚æœçŠ¶æ€éœ€è¦æ›´æ–°
                    if new_status != customer.get("status"):
                        service.update_customer_status(
                            customer["_id"],
                            customer.get("status"),
                            new_status,
                            "auto_status_update"
                        )
                        update_count += 1

                except Exception as e:
                    error_count += 1
                    errors.append({
                        "customer_id": str(customer["_id"]),
                        "customer_name": customer.get("user_name"),
                        "error": str(e)
                    })

            return {
                "success": True,
                "message": "å®¢æˆ·çŠ¶æ€æ›´æ–°å®Œæˆ",
                "statistics": {
                    "total_checked": len(customers),
                    "status_updates": update_count,
                    "errors": error_count,
                    "error_details": errors
                },
                "data": {
                    "updated_customers": update_count
                }
            }

        except Exception as e:
            return {
                "success": False,
                "message": f"å®¢æˆ·çŠ¶æ€æ›´æ–°å¤±è´¥: {str(e)}",
                "statistics": {
                    "total_checked": 0,
                    "status_updates": 0,
                    "errors": 1
                }
            }
```

## ğŸ” ç›‘æ§å’Œå‘Šè­¦

### ä»»åŠ¡ç›‘æ§æœåŠ¡

```python
class TaskMonitor:
    """ä»»åŠ¡ç›‘æ§æœåŠ¡"""

    def __init__(self, db):
        self.db = db
        self.alert_channel = AlertChannel()

    async def task_started(self, task_name: str, execution_id: str, start_time: datetime) -> None:
        """è®°å½•ä»»åŠ¡å¼€å§‹æ‰§è¡Œ"""
        self.db.task_execution_logs.insert_one({
            "task_name": task_name,
            "execution_id": execution_id,
            "status": "started",
            "start_time": start_time,
            "created_at": datetime.utcnow()
        })

    async def task_completed(self, task_name: str, execution_id: str,
                           start_time: datetime, result: Dict[str, Any]) -> None:
        """è®°å½•ä»»åŠ¡æ‰§è¡Œå®Œæˆ"""
        end_time = datetime.utcnow()
        execution_time = (end_time - start_time).total_seconds()

        self.db.task_execution_logs.insert_one({
            "task_name": task_name,
            "execution_id": execution_id,
            "status": "completed",
            "start_time": start_time,
            "end_time": end_time,
            "execution_time": execution_time,
            "result": result,
            "created_at": datetime.utcnow()
        })

        # æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦ï¼ˆä¾‹å¦‚æ‰§è¡Œæ—¶é—´è¿‡é•¿ï¼‰
        if execution_time > 3600:  # è¶…è¿‡1å°æ—¶
            self.send_alert(
                f"ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿",
                f"ä»»åŠ¡ {task_name} æ‰§è¡Œæ—¶é—´ {execution_time:.2f} ç§’ï¼Œè¶…è¿‡é¢„æœŸ",
                "warning"
            )

    async def task_failed(self, task_name: str, execution_id: str,
                         start_time: datetime, error_info: Dict[str, Any]) -> None:
        """è®°å½•ä»»åŠ¡æ‰§è¡Œå¤±è´¥"""
        end_time = datetime.utcnow()

        self.db.task_execution_logs.insert_one({
            "task_name": task_name,
            "execution_id": execution_id,
            "status": "failed",
            "start_time": start_time,
            "end_time": end_time,
            "error_info": error_info,
            "created_at": datetime.utcnow()
        })

        # å‘é€å¤±è´¥å‘Šè­¦
        self.send_alert(
            f"ä»»åŠ¡æ‰§è¡Œå¤±è´¥",
            f"ä»»åŠ¡ {task_name} æ‰§è¡Œå¤±è´¥: {error_info['error_message']}",
            "error"
        )

    def send_alert(self, title: str, message: str, alert_type: str = "info") -> None:
        """å‘é€å‘Šè­¦é€šçŸ¥"""
        # è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€çŸ­ä¿¡ã€é’‰é’‰ç­‰å‘Šè­¦æ¸ é“
        self.alert_channel.send(title, message, alert_type)
```

## ğŸ“ APIæ¥å£è®¾è®¡

### ä»»åŠ¡ç®¡ç†API

```python
@router.get("/tasks", response_model=List[Dict[str, Any]])
async def list_tasks(
    category: Optional[str] = Query(None),
    tags: Optional[str] = Query(None),
    current_user: User = Depends(get_current_active_user)
):
    """è·å–ä»»åŠ¡åˆ—è¡¨"""
    return task_service.get_task_list(category, tags)

@router.get("/tasks/{task_name}", response_model=Dict[str, Any])
async def get_task_detail(
    task_name: str,
    current_user: User = Depends(get_current_active_user)
):
    """è·å–ä»»åŠ¡è¯¦æƒ…"""
    return task_service.get_task_detail(task_name)

@router.post("/tasks/{task_name}/execute", response_model=Dict[str, Any])
async def execute_task(
    task_name: str,
    current_user: User = Depends(get_current_active_user)
):
    """æ‰‹åŠ¨æ‰§è¡Œä»»åŠ¡"""
    return await task_service.manual_execute_task(task_name)

@router.post("/tasks/{task_name}/schedule", response_model=Dict[str, Any])
async def schedule_task(
    task_name: str,
    schedule_config: Dict[str, Any],
    current_user: User = Depends(get_current_active_user)
):
    """é…ç½®ä»»åŠ¡è°ƒåº¦"""
    return task_service.schedule_task(task_name, schedule_config)

@router.get("/tasks/{task_name}/history", response_model=Dict[str, Any])
async def get_task_history(
    task_name: str,
    limit: int = Query(50),
    offset: int = Query(0),
    current_user: User = Depends(get_current_active_user)
):
    """è·å–ä»»åŠ¡æ‰§è¡Œå†å²"""
    return task_service.get_task_history(task_name, limit, offset)
```

## ğŸš€ éƒ¨ç½²å’Œé…ç½®

### è°ƒåº¦å™¨é›†æˆåˆ°ä¸»åº”ç”¨

```python
# main.py
from webapp.services.scheduler_service import SchedulerService

app = FastAPI()

@app.on_event("startup")
async def startup_event():
    # åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
    global scheduler
    scheduler = SchedulerService(DATABASE)
    await scheduler.start()
    app.state.scheduler = scheduler

@app.on_event("shutdown")
async def shutdown_event():
    # å…³é—­è°ƒåº¦å™¨
    if hasattr(app.state, 'scheduler'):
        app.state.scheduler.stop()

# æ·»åŠ å®šæ—¶ä»»åŠ¡ç®¡ç†API
app.include_router(scheduler_router, prefix="/api/v1/scheduler", tags=["Scheduler"])
```

### é…ç½®æ–‡ä»¶

```python
# config/scheduler_config.py
SCHEDULER_CONFIG = {
    "timezone": "Asia/Shanghai",
    "jobstores": {
        "default": {
            "type": "mongodb",
            "database": "exds",
            "collection": "scheduler_jobs"
        }
    },
    "executors": {
        "default": {
            "type": "threadpool",
            "max_workers": 20
        }
    },
    "job_defaults": {
        "coalesce": True,
        "max_instances": 3,
        "misfire_grace_time": 300
    },
    "alerts": {
        "enabled": True,
        "channels": ["email", "webhook"],
        "email": {
            "smtp_server": "smtp.example.com",
            "smtp_port": 587,
            "username": "alerts@example.com",
            "password": "password",
            "recipients": ["admin@example.com"]
        },
        "webhook": {
            "url": "https://hooks.slack.com/...",
            "channel": "#alerts"
        }
    }
}
```

## ğŸ“‹ å®æ–½è®¡åˆ’

### é˜¶æ®µä¸€ï¼šåŸºç¡€æ¡†æ¶ï¼ˆ1-2å‘¨ï¼‰
- [ ] åˆ›å»ºåŸºç¡€ç±»å’Œæ¥å£å®šä¹‰
- [ ] å®ç°ä»»åŠ¡æ³¨å†Œå™¨
- [ ] åˆ›å»ºè°ƒåº¦æœåŠ¡åŸºç¡€æ¡†æ¶
- [ ] å®ç°ä»»åŠ¡æŒä¹…åŒ–

### é˜¶æ®µäºŒï¼šç›‘æ§å’Œå‘Šè­¦ï¼ˆ1å‘¨ï¼‰
- [ ] å®ç°ä»»åŠ¡ç›‘æ§æœåŠ¡
- [ ] åˆ›å»ºå‘Šè­¦æœºåˆ¶
- [ ] å®ç°æ‰§è¡Œæ—¥å¿—è®°å½•

### é˜¶æ®µä¸‰ï¼šAPIå’Œç®¡ç†ç•Œé¢ï¼ˆ1-2å‘¨ï¼‰
- [ ] åˆ›å»ºä»»åŠ¡ç®¡ç†API
- [ ] å®ç°ä»»åŠ¡æ‰§è¡Œå†å²æŸ¥è¯¢
- [ ] åˆ›å»ºä»»åŠ¡ç®¡ç†å‰ç«¯ç•Œé¢

### é˜¶æ®µå››ï¼šä¸šåŠ¡ä»»åŠ¡è¿ç§»ï¼ˆ1-2å‘¨ï¼‰
- [ ] è¿ç§»ç°æœ‰å®šæ—¶ä»»åŠ¡åˆ°æ–°æ¡†æ¶
- [ ] æ·»åŠ æ–°çš„ä¸šåŠ¡ä»»åŠ¡
- [ ] æµ‹è¯•å’Œä¼˜åŒ–

### é˜¶æ®µäº”ï¼šéƒ¨ç½²å’Œä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰
- [ ] ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] æ–‡æ¡£å®Œå–„

## ğŸ”® æœªæ¥æ‰©å±•

1. **åˆ†å¸ƒå¼è°ƒåº¦**: æ”¯æŒå¤šèŠ‚ç‚¹åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦
2. **ä»»åŠ¡ä¾èµ–**: æ”¯æŒä»»åŠ¡é—´çš„ä¾èµ–å…³ç³»
3. **åŠ¨æ€é…ç½®**: æ”¯æŒè¿è¡Œæ—¶åŠ¨æ€ä¿®æ”¹ä»»åŠ¡é…ç½®
4. **å¯è§†åŒ–ç•Œé¢**: æä¾›Webç•Œé¢çš„ä»»åŠ¡ç®¡ç†å·¥å…·
5. **æ€§èƒ½ç›‘æ§**: é›†æˆAPMå·¥å…·è¿›è¡Œæ€§èƒ½ç›‘æ§
6. **æ’ä»¶æœºåˆ¶**: æ”¯æŒç¬¬ä¸‰æ–¹æ’ä»¶æ‰©å±•åŠŸèƒ½

## ğŸ“š å‚è€ƒèµ„æ–™

- [APSchedulerå®˜æ–¹æ–‡æ¡£](https://apscheduler.readthedocs.io/)
- [Pythonå®šæ—¶ä»»åŠ¡æœ€ä½³å®è·µ](https://docs.python.org/3/library/sched.html)
- [MongoDBèšåˆç®¡é“](https://docs.mongodb.com/manual/aggregation/)

---

*æœ€åæ›´æ–°æ—¶é—´ï¼š2025-11-11*
*ç‰ˆæœ¬ï¼šv1.0*