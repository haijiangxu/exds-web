# 负荷数据处理与展示技术要点

本文档旨在总结“负荷数据校验”模块开发过程中，关于数据存储、处理、聚合及前后端交互的核心技术规范与要点。

## 1. 数据存储模型 (Data Storage Model)

### 1.1. 数据纯洁性原则
- 系统必须维护两个独立的、源头纯净的负荷曲线数据库（MongoDB集合）：
  - **预测曲线 (Prediction Curve)**：来自用户手工导入的数据，用于日前预测等场景。
  - **结算曲线 (Settlement Curve)**：来自RPA系统从电网爬取的结算数据，作为事后分析的基准。
- **严禁**在数据库层面创建或持久化一个混合的“统一曲线”。数据的融合与回退只发生在应用服务的内存中。

### 1.2. 长/窄表格式 (Long/Narrow Format)
- 所有的时序数据（负荷、价格等）**必须**采用“长/窄”格式进行存储。即每个时间点的数据作为一条独立的数据库记录。
- **错误示范 (Wide Format)**:
  ```json
  { "date": "2025-11-10", "points": [23.1, 24.5, ...] }
  ```
- **正确示范 (Long Format)**:
  ```json
  { "timestamp": ISODate("2025-11-10T00:15:00Z"), "value": 23.1 }
  { "timestamp": ISODate("2025-11-10T00:30:00Z"), "value": 24.5 }
  ```
- 这种格式极大地简化了聚合、查询和索引的复杂性。

### 1.3. 24:00 时间戳处理
- 业务日中的`24:00`时刻，在数据库中应存储为**下一日的`00:00:00`**。
  - 例如，`2025-11-10`的第96个点（24:00），应存储为`2025-11-11T00:00:00Z`。
- 查询一整天（包含第96个点）的数据时，时间区间必须是**左开右闭 `(start_of_day, end_of_day]`**。
  - 例如，查询`2025-11-10`的数据，对应的MongoDB查询应为`{ "timestamp": { "$gt": ISODate("2025-11-10T00:00:00Z"), "$lte": ISODate("2025-11-11T00:00:00Z") } }`。

### 1.4. 数据存储层级
1.  **原始数据层**: 保留用户上传的原始96点手工导入数据，作为最原始的追溯依据。
2.  **工作数据层**: 存储经过清洗和处理后的48点“预测曲线”和“结算曲线”，存储粒度为**计量点（metering point）**。
3.  **聚合数据层**: 为了前端性能，客户级别的负荷曲线应通过后台定时任务或事件驱动，由计量点数据**预先聚合**生成，并存储在专门的客户级曲线集合中。

## 2. 数据导入与处理逻辑

### 2.1. 内存借用 (In-Memory Borrowing)
- 当核心业务功能（如负荷预测）需要数据时，遵循“首选预测，备选结算”的原则。
- 如果预测曲线在某个时间点缺失，业务逻辑层（Service/Engine）**在内存中**临时从结算曲线获取数据进行填充，完成计算。
- 这个“借用”过程**不会**对任何数据库集合进行写操作，保证了源数据的纯洁性。

### 2.2. 负荷预测逻辑
- 采用双模型策略：
  - **T-1高精度模型**: 优先使用前一天（T-1）的数据进行预测。
  - **T-2回退模型**: 如果T-1数据不足，则使用前两天（T-2）的数据。
- 预测任务每日自动执行，同时提供手动触发机制。
- 如果经过“内存借用”后，数据依然不足以支撑模型运行，则中止当次预测任务，并记录日志。

## 3. 数据聚合策略

### 3.1. 客户级曲线聚合
- 客户级（Customer-level）的负荷曲线**必须**通过后台任务进行预聚合，以避免前端在请求时进行实时的大数据量计算。
- 聚合任务的触发时机：在每次成功的手工导入或RPA爬取之后，通过事件驱动机制（如消息队列或简单的回调）来触发对相关客户的聚合计算。

### 3.2. 全局完整性看板缓存
- “全局数据完整性看板”的数据需要进行缓存（如使用Redis或内存缓存）。
- 缓存的失效和刷新机制同样由数据导入/爬取成功事件来驱动，确保看板数据的准实时性。

## 4. 前后端代码要点

### 4.1. 后端 (Backend - FastAPI)
- **查询接口**: 封装数据库查询逻辑，严格遵循` (start_of_day, end_of_day]` 的时间区间来获取完整的96点数据。
- **数据格式化**: API在返回给前端数据时，**有责任**将`2025-11-11T00:00:00Z`这样的时间戳，在JSON响应中格式化为业务所需的`"24:00"`字符串标签。

  ```python
  # 伪代码示例
  def format_point_for_frontend(point):
      if point['timestamp'].hour == 0 and point['timestamp'].minute == 0:
          # 假设这是前一天的第96个点
          return {"time": "24:00", "value": point['value']}
      else:
          return {"time": point['timestamp'].strftime("%H:%M"), "value": point['value']}
  ```

### 4.2. 前端 (Frontend - React)
- **数据消费**: 前端直接消费后端API返回的JSON数据。对于时间轴（X轴），直接使用API返回的`time`字段（例如`"23:45"`, `"24:00"`）。
- **无复杂逻辑**: 前端在图表展示层面，**不需要**也**不应该**进行任何复杂的日期或时间转换逻辑来处理“24:00”的问题。所有复杂性都应由后端封装。
