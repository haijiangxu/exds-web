# 多页签功能设计方案

本文档旨在整理和明确电力交易辅助决策系统前端的多页签（Tabs）功能设计，确保开发团队对需求、设计和技术实现有一致的理解。

## 1. 核心需求

1.  **多任务并行**：用户能够同时打开多个功能页面，并在它们之间自由切换，无需关闭前一个页面。
2.  **状态保持**：切换页签时，被隐藏页面的内部状态（如数据、图表、表单内容）必须被完整保留，返回该页签时应避免数据重新加载和刷新。
3.  **可管理性**：用户可以方便地关闭不再需要的页签，释放工作区空间。
4.  **跨平台适应性**：方案需同时考虑桌面端和移动端的可用性，并提供最佳的用户体验。

## 2. 整体设计思路：响应式与差异化

考虑到桌面端和移动端在屏幕尺寸、操作习惯上的巨大差异，我们采用**响应式和差异化**的设计思路：

-   **桌面端 (Desktop)**: 实现功能完整的、类似 IDE 的多页签交互界面。
-   **移动端 (Mobile)**: 保持原生、简洁的单页导航流程，不引入多页签概念。

这种方式可以确保两个平台的用户都能获得针对其设备优化的、最符合其操作习惯的体验。

## 3. 桌面端 (Desktop) 方案

### 3.1. 交互设计

-   **打开页签**: 点击侧边栏菜单项时，在主工作区打开一个新的页签。如果该页签已存在，则直接激活它。
-   **切换页签**: 用户通过点击页签栏中的不同页签，可以即时切换到对应的页面内容。
-   **菜单联动 (Menu Sync)**: 当用户通过点击页签来切换视图时，左侧的导航菜单应自动高亮显示当前激活页签所对应的菜单项，并展开其父级菜单。这为用户提供了清晰的上下文感知，并保持了界面状态的一致性。
-   **状态保持**: 切换过程是非破坏性的。非激活状态的页面仅被隐藏，其组件不会被卸载，因此所有内部 state（包括接口返回的数据、用户输入等）都会被保留。
-   **关闭页签**: 每个页签上提供一个“x”关闭按钮。关闭后，如果还有其他页签，则自动激活一个邻近的页签。

### 3.2. 技术实现

-   **核心机制**: **“CSS 隐藏”替代“组件卸载”**。
-   **状态管理**:
    -   引入一个全局状态（可通过 `React Context` 或 `Zustand` 实现）。
    -   该状态维护一个 `openTabs` 数组，记录所有已打开页签的信息（如 `key`, `title`, `component`）。
    -   同时记录 `activeTabKey`，表示当前激活的页签。
-   **UI 组件**:
    -   使用 Material-UI 的 `<Tabs>` 和 `<Tab>` 组件构建页签栏。
    -   自定义 `<Tab>` 的 `label` 属性，以嵌入标题和关闭按钮。
-   **内容渲染**:
    -   在内容区遍历 `openTabs` 数组，**渲染所有页签对应的组件**。
    -   通过 CSS `display` 属性来控制可见性：`activeTabKey` 对应的组件 `display: 'block'`，其余 `display: 'none'`。
-   **菜单联动实现**: `Sidebar` 组件需订阅全局状态中的 `activeTabKey`。在渲染时，根据此 `key` 来决定哪个菜单项应被高亮，哪个父菜单应被展开。

## 4. 移动端 (Mobile) 方案

### 4.1. 交互设计

-   **单页导航**: 不引入多页签界面。点击菜单项后，新页面将直接替换当前页面。
-   **线性流程**: 交互流程是线性的“前进-后退”模式，符合移动端用户的标准使用习惯。
-   **无状态保持**: 页面切换时，旧页面的组件会被正常卸载，其状态不会被保留。这能有效节省移动设备宝贵的内存资源。

### 4.2. 技术实现

-   **标准路由**: 使用 `react-router-dom` 的标准路由功能。
-   **布局**: 渲染一个不包含页签栏的、简洁的移动端专用布局。
-   **导航**: 侧边栏的点击事件直接触发标准的路由跳转 (`navigate('/path')`)。

## 5. 关键技术细节

### 5.1. 响应式判断

-   使用 Material-UI 的 `useMediaQuery` Hook 来动态检测当前屏幕是否为桌面端尺寸。
-   根据检测结果，在应用根组件或主布局中，条件性地渲染 `DesktopTabLayout` 或 `MobileSimpleLayout`。

```jsx
import useMediaQuery from '@mui/material/useMediaQuery';

function AppLayout() {
  // 定义断点，例如大于 960px 视为桌面端
  const isDesktop = useMediaQuery(theme => theme.breakpoints.up('md'));

  return (
    <>
      {isDesktop ? <DesktopTabLayout /> : <MobileSimpleLayout />}
    </>
  );
}
```

## 6. 总结

该方案通过差异化设计，为不同平台提供了最优的交互体验。桌面端实现了强大的多任务处理能力和流畅的状态保持，而移动端则保证了简洁性和对原生操作习惯的遵从。虽然增加了初期的开发复杂度，但能显著提升最终产品的可用性和用户满意度。
