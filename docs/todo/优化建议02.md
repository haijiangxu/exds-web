# 前端会话过期处理优化方案 (混合模式)

本文档提出一种更健壮、用户体验更佳的前端会话过期处理方案。该方案结合了“前端主动超时”和“API响应拦截”两种机制，确保在任何情况下都能正确处理用户会话状态。

## 方案概述

核心思想是：前端在用户登录后，根据令牌（JWT）的有效期启动一个**主动登出定时器**，以处理用户长时间静默在线的情况；同时，保留一个**API 401响应拦截器**作为最终的“安全网”，处理网络延迟、时钟不同步等边缘情况。

---

### 步骤一：前端主动超时机制

此机制负责在令牌有效期到达的那一刻，主动将用户登出。

#### 1. 在登录时解析 JWT 并启动定时器

- **安装解码库:** 首先需要一个小工具库 `jwt-decode` 来安全地解析 JWT 的内容。
  ```bash
  npm install jwt-decode --prefix frontend
  ```
- **解析过期时间:** 用户登录成功并获取 JWT 后，使用 `jwt-decode` 解析其载荷（Payload），读取 `exp` 字段。这是一个标准的 Unix 时间戳，代表令牌的到期时刻。
- **计算剩余时间:** 用 `exp` 时间戳（需转换为毫秒）减去当前时间，得到剩余的有效毫秒数 `expiresIn`。
- **启动定时器:** 调用 `setTimeout(logoutFunction, expiresIn)`，在令牌到期的那一刻自动执行登出逻辑。

#### 2. 创建全局认证上下文 (`AuthContext`)

为了在整个应用中统一管理登录状态和定时器，最佳实践是创建一个 `AuthContext`。

- **`AuthProvider` 组件:**
  - 它会包裹整个应用，内部维护用户的登录状态和“超时定时器”的 ID。
  - **提供 `login` 方法:** 当调用时，此方法会保存 JWT、解析过期时间、启动登出定时器。
  - **提供 `logout` 方法:** 当用户**主动点击登出**或**定时器到期**时，此方法会清除本地存储的 JWT、清除定时器，并强制重定向到登录页。
- **处理浏览器刷新/重开:**
  - 当应用加载时，`AuthProvider` 会检查本地存储中是否存在 JWT。
  - 如果存在，则解码并检查**是否已经过期**。
    - 若已过期，立即执行登出。
    - 若未过期，则重新计算剩余时间，并启动一个新的登出定时器。

---

### 步骤二：保留 401 拦截器作为“安全网”

在 `src/api/client.ts` 中，我们仍然需要保留（或添加）`axios` 的401响应拦截器。

- **为什么必须保留？**
  - **网络延迟:** 用户的 API 请求可能在前端定时器触发的瞬间才到达服务器，此时令牌刚好过期。
  - **时钟不同步:** 用户本地设备的系统时间可能不准确，导致前端定时器与服务器的判断存在偏差。
  - **服务器端吊销:** 在某些情况下，令牌可能在过期前就被服务器判定为无效。
- **作用:** 401 拦截器是一个**最终的、绝对可靠的防线**，确保任何因认证无效而被拒绝的请求都能被正确捕获，并强制用户返回登录页面。

---

### 方案总结

| 方案 | 触发时机 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **被动拦截 (仅401)** | 用户进行 API 操作时 | 实现简单，绝对可靠 | 用户长时间不操作，页面会一直“假在线” |
| **主动超时 (仅定时器)** | 登录后，时间一到就触发 | 体验好，能处理静默超时 | 依赖客户端时钟，可能存在微小误差 |
| **混合方案 (推荐)** | 两者并存 | **兼具两者优点，体验好且绝对可靠** | 实现稍复杂，但结构清晰，一劳永逸 |

**结论:** 强烈推荐采用**混合方案**，它能提供最无缝、最安全的用户体验。
